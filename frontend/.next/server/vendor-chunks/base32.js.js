"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/base32.js";
exports.ids = ["vendor-chunks/base32.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/base32.js/base32.js":
/*!******************************************!*\
  !*** ./node_modules/base32.js/base32.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n}\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\n\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\n\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\n\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder (options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | (symbol >> -shift));\n      shift += 8;\n      carry = (symbol << shift) & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\nfunction Encoder (options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;\n    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | (byte >> shift);\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2Jhc2UzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixpQkFBaUIiLCJzb3VyY2VzIjpbIi9ob21lL1RhcnVuU2luZ2gvRG9jdW1lbnRzL3N0ZWxsZXIvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2Jhc2UzMi5qcy9iYXNlMzIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjaGFyYWN0ZXIgbWFwLlxuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0IGUuZy4gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiXG4gKiBAcGFyYW0ge29iamVjdH0gbWFwcGluZ3MgbWFwIG92ZXJyaWRlcyBmcm9tIGtleSB0byB2YWx1ZVxuICogQG1ldGhvZFxuICovXG5cbnZhciBjaGFybWFwID0gZnVuY3Rpb24gKGFscGhhYmV0LCBtYXBwaW5ncykge1xuICBtYXBwaW5ncyB8fCAobWFwcGluZ3MgPSB7fSk7XG4gIGFscGhhYmV0LnNwbGl0KFwiXCIpLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICBpZiAoIShjIGluIG1hcHBpbmdzKSkgbWFwcGluZ3NbY10gPSBpO1xuICB9KTtcbiAgcmV0dXJuIG1hcHBpbmdzO1xufVxuXG4vKipcbiAqIFRoZSBSRkMgNDY0OCBiYXNlIDMyIGFscGhhYmV0IGFuZCBjaGFyYWN0ZXIgbWFwLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDh9XG4gKi9cblxudmFyIHJmYzQ2NDggPSB7XG4gIGFscGhhYmV0OiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIsXG4gIGNoYXJtYXA6IHtcbiAgICAwOiAxNCxcbiAgICAxOiA4XG4gIH1cbn07XG5cbnJmYzQ2NDguY2hhcm1hcCA9IGNoYXJtYXAocmZjNDY0OC5hbHBoYWJldCwgcmZjNDY0OC5jaGFybWFwKTtcblxuLyoqXG4gKiBUaGUgQ3JvY2tmb3JkIGJhc2UgMzIgYWxwaGFiZXQgYW5kIGNoYXJhY3RlciBtYXAuXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmNyb2NrZm9yZC5jb20vd3JtZy9iYXNlMzIuaHRtbH1cbiAqL1xuXG52YXIgY3JvY2tmb3JkID0ge1xuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWlwiLFxuICBjaGFybWFwOiB7XG4gICAgTzogMCxcbiAgICBJOiAxLFxuICAgIEw6IDFcbiAgfVxufTtcblxuY3JvY2tmb3JkLmNoYXJtYXAgPSBjaGFybWFwKGNyb2NrZm9yZC5hbHBoYWJldCwgY3JvY2tmb3JkLmNoYXJtYXApO1xuXG4vKipcbiAqIGJhc2UzMmhleFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTMyI2Jhc2UzMmhleH1cbiAqL1xuXG52YXIgYmFzZTMyaGV4ID0ge1xuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVlwiLFxuICBjaGFybWFwOiB7fVxufTtcblxuYmFzZTMyaGV4LmNoYXJtYXAgPSBjaGFybWFwKGJhc2UzMmhleC5hbHBoYWJldCwgYmFzZTMyaGV4LmNoYXJtYXApO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgRGVjb2RlcmAgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiAgIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gU3VwcG9ydGVkIEJhc2UtMzIgdmFyaWFudHMgYXJlIFwicmZjNDY0OFwiIGFuZFxuICogICAgIFwiY3JvY2tmb3JkXCIuXG4gKiAgIEBwYXJhbSB7b2JqZWN0fSBbY2hhcm1hcF0gT3ZlcnJpZGUgdGhlIGNoYXJhY3RlciBtYXAgdXNlZCBpbiBkZWNvZGluZy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIERlY29kZXIgKG9wdGlvbnMpIHtcbiAgdGhpcy5idWYgPSBbXTtcbiAgdGhpcy5zaGlmdCA9IDg7XG4gIHRoaXMuY2FycnkgPSAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgICAgY2FzZSBcInJmYzQ2NDhcIjpcbiAgICAgICAgdGhpcy5jaGFybWFwID0gZXhwb3J0cy5yZmM0NjQ4LmNoYXJtYXA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNyb2NrZm9yZFwiOlxuICAgICAgICB0aGlzLmNoYXJtYXAgPSBleHBvcnRzLmNyb2NrZm9yZC5jaGFybWFwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiYXNlMzJoZXhcIjpcbiAgICAgICAgdGhpcy5jaGFybWFwID0gZXhwb3J0cy5iYXNlMzJoZXguY2hhcm1hcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR5cGVcIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2hhcm1hcCkgdGhpcy5jaGFybWFwID0gb3B0aW9ucy5jaGFybWFwO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgY2hhcmFjdGVyIG1hcCBjb3Jlc3BvbmRzIHRvIFJGQzQ2NDguXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuY2hhcm1hcCA9IHJmYzQ2NDguY2hhcm1hcDtcblxuLyoqXG4gKiBEZWNvZGUgYSBzdHJpbmcsIGNvbnRpbnVpbmcgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7RGVjb2Rlcn0gdGhpc1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgY2hhcm1hcCA9IHRoaXMuY2hhcm1hcDtcbiAgdmFyIGJ1ZiA9IHRoaXMuYnVmO1xuICB2YXIgc2hpZnQgPSB0aGlzLnNoaWZ0O1xuICB2YXIgY2FycnkgPSB0aGlzLmNhcnJ5O1xuXG4gIC8vIGRlY29kZSBzdHJpbmdcbiAgc3RyLnRvVXBwZXJDYXNlKCkuc3BsaXQoXCJcIikuZm9yRWFjaChmdW5jdGlvbiAoY2hhcikge1xuXG4gICAgLy8gaWdub3JlIHBhZGRpbmdcbiAgICBpZiAoY2hhciA9PSBcIj1cIikgcmV0dXJuO1xuXG4gICAgLy8gbG9va3VwIHN5bWJvbFxuICAgIHZhciBzeW1ib2wgPSBjaGFybWFwW2NoYXJdICYgMHhmZjtcblxuICAgIC8vIDE6IDAwMDAwIDAwMFxuICAgIC8vIDI6ICAgICAgICAgIDAwIDAwMDAwIDBcbiAgICAvLyAzOiAgICAgICAgICAgICAgICAgICAgMDAwMCAwMDAwXG4gICAgLy8gNDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgMDAwMDAgMDBcbiAgICAvLyA1OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMCAwMDAwMFxuICAgIC8vIDY6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwMDAgMDAwXG4gICAgLy8gNzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMCAwMDAwMCAwXG5cbiAgICBzaGlmdCAtPSA1O1xuICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgIGNhcnJ5IHw9IHN5bWJvbCA8PCBzaGlmdDtcbiAgICB9IGVsc2UgaWYgKHNoaWZ0IDwgMCkge1xuICAgICAgYnVmLnB1c2goY2FycnkgfCAoc3ltYm9sID4+IC1zaGlmdCkpO1xuICAgICAgc2hpZnQgKz0gODtcbiAgICAgIGNhcnJ5ID0gKHN5bWJvbCA8PCBzaGlmdCkgJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWYucHVzaChjYXJyeSB8IHN5bWJvbCk7XG4gICAgICBzaGlmdCA9IDg7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfVxuICB9KTtcblxuICAvLyBzYXZlIHN0YXRlXG4gIHRoaXMuc2hpZnQgPSBzaGlmdDtcbiAgdGhpcy5jYXJyeSA9IGNhcnJ5O1xuXG4gIC8vIGZvciBjaGFpbmluZ1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoIGRlY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyXSBUaGUgZmluYWwgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEByZXR1cm4ge0FycmF5fSBEZWNvZGVkIGJ5dGUgYXJyYXkuXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmIChzdHIpIHtcbiAgICB0aGlzLndyaXRlKHN0cik7XG4gIH1cbiAgaWYgKHRoaXMuc2hpZnQgIT09IDggJiYgdGhpcy5jYXJyeSAhPT0gMCkge1xuICAgIHRoaXMuYnVmLnB1c2godGhpcy5jYXJyeSk7XG4gICAgdGhpcy5zaGlmdCA9IDg7XG4gICAgdGhpcy5jYXJyeSA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYnVmO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYEVuY29kZXJgIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogICBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIFN1cHBvcnRlZCBCYXNlLTMyIHZhcmlhbnRzIGFyZSBcInJmYzQ2NDhcIiBhbmRcbiAqICAgICBcImNyb2NrZm9yZFwiLlxuICogICBAcGFyYW0ge29iamVjdH0gW2FscGhhYmV0XSBPdmVycmlkZSB0aGUgYWxwaGFiZXQgdXNlZCBpbiBlbmNvZGluZy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIgKG9wdGlvbnMpIHtcbiAgdGhpcy5idWYgPSBcIlwiO1xuICB0aGlzLnNoaWZ0ID0gMztcbiAgdGhpcy5jYXJyeSA9IDA7XG5cbiAgaWYgKG9wdGlvbnMpIHtcblxuICAgIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgICBjYXNlIFwicmZjNDY0OFwiOlxuICAgICAgICB0aGlzLmFscGhhYmV0ID0gZXhwb3J0cy5yZmM0NjQ4LmFscGhhYmV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjcm9ja2ZvcmRcIjpcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGV4cG9ydHMuY3JvY2tmb3JkLmFscGhhYmV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiYXNlMzJoZXhcIjpcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGV4cG9ydHMuYmFzZTMyaGV4LmFscGhhYmV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZVwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbHBoYWJldCkgdGhpcy5hbHBoYWJldCA9IG9wdGlvbnMuYWxwaGFiZXQ7XG4gICAgZWxzZSBpZiAob3B0aW9ucy5sYykgdGhpcy5hbHBoYWJldCA9IHRoaXMuYWxwaGFiZXQudG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFscGhhYmV0IGNvcmVzcG9uZHMgdG8gUkZDNDY0OC5cbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5hbHBoYWJldCA9IHJmYzQ2NDguYWxwaGFiZXQ7XG5cbi8qKlxuICogRW5jb2RlIGEgYnl0ZSBhcnJheSwgY29udGludWluZyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge2J5dGVbXX0gYnVmIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm4ge0VuY29kZXJ9IHRoaXNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdmFyIHNoaWZ0ID0gdGhpcy5zaGlmdDtcbiAgdmFyIGNhcnJ5ID0gdGhpcy5jYXJyeTtcbiAgdmFyIHN5bWJvbDtcbiAgdmFyIGJ5dGU7XG4gIHZhciBpO1xuXG4gIC8vIGVuY29kZSBlYWNoIGJ5dGUgaW4gYnVmXG4gIGZvciAoaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlID0gYnVmW2ldO1xuXG4gICAgLy8gMTogMDAwMDAgMDAwXG4gICAgLy8gMjogICAgICAgICAgMDAgMDAwMDAgMFxuICAgIC8vIDM6ICAgICAgICAgICAgICAgICAgICAwMDAwIDAwMDBcbiAgICAvLyA0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAwMDAwMCAwMFxuICAgIC8vIDU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDAwIDAwMDAwXG4gICAgLy8gNjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAwMCAwMDBcbiAgICAvLyA3OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwIDAwMDAwIDBcblxuICAgIHN5bWJvbCA9IGNhcnJ5IHwgKGJ5dGUgPj4gc2hpZnQpO1xuICAgIHRoaXMuYnVmICs9IHRoaXMuYWxwaGFiZXRbc3ltYm9sICYgMHgxZl07XG5cbiAgICBpZiAoc2hpZnQgPiA1KSB7XG4gICAgICBzaGlmdCAtPSA1O1xuICAgICAgc3ltYm9sID0gYnl0ZSA+PiBzaGlmdDtcbiAgICAgIHRoaXMuYnVmICs9IHRoaXMuYWxwaGFiZXRbc3ltYm9sICYgMHgxZl07XG4gICAgfVxuXG4gICAgc2hpZnQgPSA1IC0gc2hpZnQ7XG4gICAgY2FycnkgPSBieXRlIDw8IHNoaWZ0O1xuICAgIHNoaWZ0ID0gOCAtIHNoaWZ0O1xuICB9XG5cbiAgLy8gc2F2ZSBzdGF0ZVxuICB0aGlzLnNoaWZ0ID0gc2hpZnQ7XG4gIHRoaXMuY2FycnkgPSBjYXJyeTtcblxuICAvLyBmb3IgY2hhaW5pbmdcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaCBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge2J5dGVbXX0gW2J1Zl0gVGhlIGZpbmFsIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZW5jb2RlZCBieXRlIGFycmF5LlxuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmKSB7XG4gICAgdGhpcy53cml0ZShidWYpO1xuICB9XG4gIGlmICh0aGlzLnNoaWZ0ICE9PSAzKSB7XG4gICAgdGhpcy5idWYgKz0gdGhpcy5hbHBoYWJldFt0aGlzLmNhcnJ5ICYgMHgxZl07XG4gICAgdGhpcy5zaGlmdCA9IDM7XG4gICAgdGhpcy5jYXJyeSA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYnVmO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBlbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7Ynl0ZVtdfSBidWYgVGhlIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIGVuY29kZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChidWYsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyKG9wdGlvbnMpLmZpbmFsaXplKGJ1Zik7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBkZWNvZGVyLlxuICogQHJldHVybiB7Ynl0ZVtdfSBUaGUgZGVjb2RlZCBieXRlIGFycmF5LlxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IERlY29kZXIob3B0aW9ucykuZmluYWxpemUoc3RyKTtcbn07XG5cbi8vIEV4cG9ydHMuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcbmV4cG9ydHMuY2hhcm1hcCA9IGNoYXJtYXA7XG5leHBvcnRzLmNyb2NrZm9yZCA9IGNyb2NrZm9yZDtcbmV4cG9ydHMucmZjNDY0OCA9IHJmYzQ2NDg7XG5leHBvcnRzLmJhc2UzMmhleCA9IGJhc2UzMmhleDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/base32.js/base32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/base32.js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base32.js/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// Module dependencies.\nvar base32 = __webpack_require__(/*! ./base32 */ \"(ssr)/./node_modules/base32.js/base32.js\");\n\n\n// Wrap decoder finalize to return a buffer;\nvar finalizeDecode = base32.Decoder.prototype.finalize;\nbase32.Decoder.prototype.finalize = function (buf) {\n  var bytes = finalizeDecode.call(this, buf);\n  return new Buffer(bytes);\n};\n\n\n// Export Base32.\nmodule.exports = base32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFzZTMyLmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLDBEQUFVOzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9UYXJ1blNpbmdoL0RvY3VtZW50cy9zdGVsbGVyL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9iYXNlMzIuanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG52YXIgYmFzZTMyID0gcmVxdWlyZShcIi4vYmFzZTMyXCIpO1xuXG5cbi8vIFdyYXAgZGVjb2RlciBmaW5hbGl6ZSB0byByZXR1cm4gYSBidWZmZXI7XG52YXIgZmluYWxpemVEZWNvZGUgPSBiYXNlMzIuRGVjb2Rlci5wcm90b3R5cGUuZmluYWxpemU7XG5iYXNlMzIuRGVjb2Rlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHZhciBieXRlcyA9IGZpbmFsaXplRGVjb2RlLmNhbGwodGhpcywgYnVmKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIoYnl0ZXMpO1xufTtcblxuXG4vLyBFeHBvcnQgQmFzZTMyLlxubW9kdWxlLmV4cG9ydHMgPSBiYXNlMzI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/base32.js/index.js\n");

/***/ })

};
;