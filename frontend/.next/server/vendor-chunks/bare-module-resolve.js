/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bare-module-resolve";
exports.ids = ["vendor-chunks/bare-module-resolve"];
exports.modules = {

/***/ "(ssr)/./node_modules/bare-module-resolve/index.js":
/*!***************************************************!*\
  !*** ./node_modules/bare-module-resolve/index.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { satisfies } = __webpack_require__(/*! bare-semver */ \"(ssr)/./node_modules/bare-semver/index.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bare-module-resolve/lib/errors.js\")\n\nmodule.exports = exports = function resolve(\n  specifier,\n  parentURL,\n  opts,\n  readPackage\n) {\n  if (typeof opts === 'function') {\n    readPackage = opts\n    opts = {}\n  } else if (typeof readPackage !== 'function') {\n    readPackage = defaultReadPackage\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      const generator = exports.module(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    },\n\n    async *[Symbol.asyncIterator]() {\n      const generator = exports.module(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(await readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    }\n  }\n}\n\nfunction defaultReadPackage() {\n  return null\n}\n\n// No resolution candidate was yielded\nconst UNRESOLVED = 0x0\n// At least 1 resolution candidate was yielded\nconst YIELDED = 0x1\n// At least 1 resolution candidate was yielded and resolved\nconst RESOLVED = YIELDED | 0x2\n\nexports.constants = {\n  UNRESOLVED,\n  YIELDED,\n  RESOLVED\n}\n\nexports.module = function* (specifier, parentURL, opts = {}) {\n  const { resolutions = null, imports = null } = opts\n\n  if (exports.startsWithWindowsDriveLetter(specifier)) {\n    specifier = '/' + specifier\n  }\n\n  let status\n\n  if (resolutions) {\n    status = yield* exports.preresolved(specifier, resolutions, parentURL, opts)\n\n    if (status) return status\n  }\n\n  status = yield* exports.url(specifier, parentURL, opts)\n\n  if (status) return status\n\n  status = yield* exports.packageImports(specifier, parentURL, opts)\n\n  if (status) return status\n\n  if (\n    specifier === '.' ||\n    specifier === '..' ||\n    specifier[0] === '/' ||\n    specifier[0] === '\\\\' ||\n    specifier.startsWith('./') ||\n    specifier.startsWith('.\\\\') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('..\\\\')\n  ) {\n    if (imports) {\n      status = yield* exports.packageImportsExports(\n        specifier,\n        imports,\n        parentURL,\n        true,\n        opts\n      )\n\n      if (status) return status\n    }\n\n    status = yield* exports.file(specifier, parentURL, false, opts)\n\n    if (status === RESOLVED) return status\n\n    return yield* exports.directory(specifier, parentURL, opts)\n  }\n\n  return yield* exports.package(specifier, parentURL, opts)\n}\n\nexports.url = function* (url, parentURL, opts = {}) {\n  const { imports = null } = opts\n\n  let resolution\n  try {\n    resolution = new URL(url)\n  } catch {\n    return UNRESOLVED\n  }\n\n  if (imports) {\n    const status = yield* exports.packageImportsExports(\n      resolution.href,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  if (resolution.protocol === 'node:') {\n    const specifier = resolution.pathname\n\n    if (\n      specifier === '.' ||\n      specifier === '..' ||\n      specifier[0] === '/' ||\n      specifier.startsWith('./') ||\n      specifier.startsWith('../')\n    ) {\n      throw errors.INVALID_MODULE_SPECIFIER(\n        `Module specifier '${url}' is not a valid package name`\n      )\n    }\n\n    return yield* exports.package(specifier, parentURL, opts)\n  }\n\n  const resolved = yield { resolution }\n\n  return resolved ? RESOLVED : YIELDED\n}\n\nexports.preresolved = function* (specifier, resolutions, parentURL, opts = {}) {\n  const imports = resolutions[parentURL.href]\n\n  if (typeof imports === 'object' && imports !== null) {\n    return yield* exports.packageImportsExports(\n      specifier,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n  }\n\n  return UNRESOLVED\n}\n\nexports[\"package\"] = function* (packageSpecifier, parentURL, opts = {}) {\n  const { builtins = [] } = opts\n\n  if (packageSpecifier === '') {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let packageName\n\n  if (packageSpecifier[0] !== '@') {\n    packageName = packageSpecifier.split('/', 1).join()\n  } else {\n    if (!packageSpecifier.includes('/')) {\n      throw errors.INVALID_MODULE_SPECIFIER(\n        `Module specifier '${packageSpecifier}' is not a valid package name`\n      )\n    }\n\n    packageName = packageSpecifier.split('/', 2).join('/')\n  }\n\n  if (\n    packageName[0] === '.' ||\n    packageName.includes('\\\\') ||\n    packageName.includes('%')\n  ) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let status\n\n  status = yield* exports.builtinTarget(packageSpecifier, null, builtins, opts)\n\n  if (status) return status\n\n  let packageSubpath = '.' + packageSpecifier.substring(packageName.length)\n\n  status = yield* exports.packageSelf(\n    packageName,\n    packageSubpath,\n    parentURL,\n    opts\n  )\n\n  if (status) return status\n\n  parentURL = new URL(parentURL.href)\n\n  do {\n    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)\n\n    parentURL.pathname = parentURL.pathname.substring(\n      0,\n      parentURL.pathname.lastIndexOf('/')\n    )\n\n    const info = yield { package: new URL('package.json', packageURL) }\n\n    if (info) {\n      if (info.engines) exports.validateEngines(packageURL, info.engines, opts)\n\n      if (info.exports) {\n        return yield* exports.packageExports(\n          packageURL,\n          packageSubpath,\n          info.exports,\n          opts\n        )\n      }\n\n      if (packageSubpath === '.') {\n        if (typeof info.main === 'string' && info.main !== '') {\n          packageSubpath = info.main\n        } else {\n          return yield* exports.file('index', packageURL, true, opts)\n        }\n      }\n\n      status = yield* exports.file(packageSubpath, packageURL, false, opts)\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(packageSubpath, packageURL, opts)\n    }\n  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')\n\n  return UNRESOLVED\n}\n\nexports.packageSelf = function* (\n  packageName,\n  packageSubpath,\n  parentURL,\n  opts = {}\n) {\n  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.name !== packageName) return false\n\n      if (info.exports) {\n        return yield* exports.packageExports(\n          packageURL,\n          packageSubpath,\n          info.exports,\n          opts\n        )\n      }\n\n      if (packageSubpath === '.') {\n        if (typeof info.main === 'string' && info.main !== '') {\n          packageSubpath = info.main\n        } else {\n          return yield* exports.file('index', packageURL, true, opts)\n        }\n      }\n\n      const status = yield* exports.file(\n        packageSubpath,\n        packageURL,\n        false,\n        opts\n      )\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(packageSubpath, packageURL, opts)\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.packageExports = function* (\n  packageURL,\n  subpath,\n  packageExports,\n  opts = {}\n) {\n  if (subpath === '.') {\n    let mainExport\n\n    if (typeof packageExports === 'string' || Array.isArray(packageExports)) {\n      mainExport = packageExports\n    } else if (typeof packageExports === 'object' && packageExports !== null) {\n      const keys = Object.keys(packageExports)\n\n      if (keys.some((key) => key.startsWith('.'))) {\n        if ('.' in packageExports) mainExport = packageExports['.']\n      } else {\n        mainExport = packageExports\n      }\n    }\n\n    if (mainExport) {\n      const status = yield* exports.packageTarget(\n        packageURL,\n        mainExport,\n        null,\n        false,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof packageExports === 'object' && packageExports !== null) {\n    const keys = Object.keys(packageExports)\n\n    if (keys.every((key) => key.startsWith('.'))) {\n      const status = yield* exports.packageImportsExports(\n        subpath,\n        packageExports,\n        packageURL,\n        false,\n        opts\n      )\n\n      if (status) return status\n    }\n  }\n\n  packageURL = new URL('package.json', packageURL)\n\n  throw errors.PACKAGE_PATH_NOT_EXPORTED(\n    `Package subpath '${subpath}' is not defined by \"exports\" in '${packageURL}'`\n  )\n}\n\nexports.packageImports = function* (specifier, parentURL, opts = {}) {\n  const { imports = null } = opts\n\n  if (specifier === '#' || specifier.startsWith('#/')) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${specifier}' is not a valid internal imports specifier`\n    )\n  }\n\n  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.imports) {\n        const status = yield* exports.packageImportsExports(\n          specifier,\n          info.imports,\n          packageURL,\n          true,\n          opts\n        )\n\n        if (status) return status\n      }\n\n      if (specifier.startsWith('#')) {\n        throw errors.PACKAGE_IMPORT_NOT_DEFINED(\n          `Package import specifier '${specifier}' is not defined by \"imports\" in '${packageURL}'`\n        )\n      }\n\n      break\n    }\n  }\n\n  if (imports) {\n    const status = yield* exports.packageImportsExports(\n      specifier,\n      imports,\n      parentURL,\n      true,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.packageImportsExports = function* (\n  matchKey,\n  matchObject,\n  packageURL,\n  isImports,\n  opts = {}\n) {\n  if (matchKey in matchObject && !matchKey.includes('*')) {\n    const target = matchObject[matchKey]\n\n    return yield* exports.packageTarget(\n      packageURL,\n      target,\n      null,\n      isImports,\n      opts\n    )\n  }\n\n  const expansionKeys = Object.keys(matchObject)\n    .filter((key) => key.includes('*'))\n    .sort(exports.patternKeyCompare)\n\n  for (const expansionKey of expansionKeys) {\n    const patternIndex = expansionKey.indexOf('*')\n    const patternBase = expansionKey.substring(0, patternIndex)\n\n    if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {\n      const patternTrailer = expansionKey.substring(patternIndex + 1)\n\n      if (\n        patternTrailer === '' ||\n        (matchKey.endsWith(patternTrailer) &&\n          matchKey.length >= expansionKey.length)\n      ) {\n        const target = matchObject[expansionKey]\n\n        const patternMatch = matchKey.substring(\n          patternBase.length,\n          matchKey.length - patternTrailer.length\n        )\n\n        return yield* exports.packageTarget(\n          packageURL,\n          target,\n          patternMatch,\n          isImports,\n          opts\n        )\n      }\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.validateEngines = function validateEngines(\n  packageURL,\n  packageEngines,\n  opts = {}\n) {\n  const { engines = {} } = opts\n\n  for (const [engine, range] of Object.entries(packageEngines)) {\n    if (engine in engines) {\n      const version = engines[engine]\n\n      if (!satisfies(version, range)) {\n        packageURL = new URL('package.json', packageURL)\n\n        throw errors.UNSUPPORTED_ENGINE(\n          `Package not compatible with engine '${engine}' ${version}, requires range '${range}' defined by \"engines\" in '${packageURL}'`\n        )\n      }\n    }\n  }\n}\n\nexports.patternKeyCompare = function patternKeyCompare(keyA, keyB) {\n  const patternIndexA = keyA.indexOf('*')\n  const patternIndexB = keyB.indexOf('*')\n  const baseLengthA = patternIndexA === -1 ? keyA.length : patternIndexA + 1\n  const baseLengthB = patternIndexB === -1 ? keyB.length : patternIndexB + 1\n  if (baseLengthA > baseLengthB) return -1\n  if (baseLengthB > baseLengthA) return 1\n  if (patternIndexA === -1) return 1\n  if (patternIndexB === -1) return -1\n  if (keyA.length > keyB.length) return -1\n  if (keyB.length > keyA.length) return 1\n  return 0\n}\n\nexports.packageTarget = function* (\n  packageURL,\n  target,\n  patternMatch,\n  isImports,\n  opts = {}\n) {\n  const { conditions = [], matchedConditions = [] } = opts\n\n  if (typeof target === 'string') {\n    if (!target.startsWith('./') && !isImports) {\n      packageURL = new URL('package.json', packageURL)\n\n      throw errors.INVALID_PACKAGE_TARGET(\n        `Invalid target '${target}' defined by \"exports\" in '${packageURL}'`\n      )\n    }\n\n    if (patternMatch !== null) {\n      target = target.replaceAll('*', patternMatch)\n    }\n\n    const status = yield* exports.url(target, packageURL, opts)\n\n    if (status) return status\n\n    if (\n      target === '.' ||\n      target === '..' ||\n      target[0] === '/' ||\n      target.startsWith('./') ||\n      target.startsWith('../')\n    ) {\n      const resolved = yield { resolution: new URL(target, packageURL) }\n\n      return resolved ? RESOLVED : YIELDED\n    }\n\n    return yield* exports.package(target, packageURL, opts)\n  }\n\n  if (Array.isArray(target)) {\n    for (const targetValue of target) {\n      const status = yield* exports.packageTarget(\n        packageURL,\n        targetValue,\n        patternMatch,\n        isImports,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof target === 'object' && target !== null) {\n    let status = UNRESOLVED\n\n    for (const [condition, targetValue, subset] of exports.conditionMatches(\n      target,\n      conditions,\n      opts\n    )) {\n      matchedConditions.push(condition)\n\n      status |= yield* exports.packageTarget(\n        packageURL,\n        targetValue,\n        patternMatch,\n        isImports,\n        { ...opts, conditions: subset }\n      )\n\n      matchedConditions.pop()\n    }\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.builtinTarget = function* (\n  packageSpecifier,\n  packageVersion,\n  target,\n  opts = {}\n) {\n  const {\n    builtinProtocol = 'builtin:',\n    conditions = [],\n    matchedConditions = []\n  } = opts\n\n  if (typeof target === 'string') {\n    const targetParts = target.split('@')\n\n    let targetName\n    let targetVersion\n\n    if (target[0] !== '@') {\n      targetName = targetParts[0]\n      targetVersion = targetParts[1] || null\n    } else {\n      targetName = targetParts.slice(0, 2).join('@')\n      targetVersion = targetParts[2] || null\n    }\n\n    if (packageSpecifier === targetName) {\n      if (packageVersion === null && targetVersion === null) {\n        const resolved = yield {\n          resolution: new URL(builtinProtocol + packageSpecifier)\n        }\n\n        return resolved ? RESOLVED : YIELDED\n      }\n\n      let version = null\n\n      if (packageVersion === null) {\n        version = targetVersion\n      } else if (targetVersion === null || packageVersion === targetVersion) {\n        version = packageVersion\n      }\n\n      if (version !== null) {\n        const resolved = yield {\n          resolution: new URL(\n            builtinProtocol + packageSpecifier + '@' + version\n          )\n        }\n\n        return resolved ? RESOLVED : YIELDED\n      }\n    }\n  } else if (Array.isArray(target)) {\n    for (const targetValue of target) {\n      const status = yield* exports.builtinTarget(\n        packageSpecifier,\n        packageVersion,\n        targetValue,\n        opts\n      )\n\n      if (status) return status\n    }\n  } else if (typeof target === 'object' && target !== null) {\n    let status = UNRESOLVED\n\n    for (const [condition, targetValue, subset] of exports.conditionMatches(\n      target,\n      conditions,\n      opts\n    )) {\n      matchedConditions.push(condition)\n\n      status |= yield* exports.builtinTarget(\n        packageSpecifier,\n        packageVersion,\n        targetValue,\n        { ...opts, conditions: subset }\n      )\n\n      matchedConditions.pop()\n    }\n\n    if (status) return status\n  }\n\n  return UNRESOLVED\n}\n\nexports.conditionMatches = function* conditionMatches(\n  target,\n  conditions,\n  opts = {}\n) {\n  if (conditions.every((condition) => typeof condition === 'string')) {\n    const keys = Object.keys(target)\n\n    for (const condition of keys) {\n      if (condition === 'default' || conditions.includes(condition)) {\n        yield [condition, target[condition], conditions]\n\n        return true\n      }\n    }\n\n    return false\n  }\n\n  let yielded = false\n\n  for (const subset of conditions) {\n    if (yield* conditionMatches(target, subset, opts)) {\n      yielded = true\n    }\n  }\n\n  return yielded\n}\n\nexports.lookupPackageScope = function* lookupPackageScope(url, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (resolutions) {\n    for (const { resolution } of exports.preresolved(\n      '#package',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n\n    // Internal preresolution path, do not depend on this! It will be removed without\n    // warning.\n    for (const { resolution } of exports.preresolved(\n      'bare:package',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n  }\n\n  const scopeURL = new URL(url.href)\n\n  do {\n    if (scopeURL.pathname.endsWith('/node_modules')) break\n\n    yield new URL('package.json', scopeURL)\n\n    scopeURL.pathname = scopeURL.pathname.substring(\n      0,\n      scopeURL.pathname.lastIndexOf('/')\n    )\n\n    if (\n      scopeURL.pathname.length === 3 &&\n      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))\n    ) {\n      break\n    }\n  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')\n}\n\nexports.file = function* (filename, parentURL, isIndex, opts = {}) {\n  if (\n    filename === '.' ||\n    filename === '..' ||\n    filename[filename.length - 1] === '/' ||\n    filename[filename.length - 1] === '\\\\'\n  ) {\n    return UNRESOLVED\n  }\n\n  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {\n    throw errors.INVALID_MODULE_SPECIFIER(\n      `Module specifier '${filename}' is invalid`\n    )\n  }\n\n  const { extensions = [] } = opts\n\n  let status = UNRESOLVED\n\n  if (!isIndex) {\n    if (yield { resolution: new URL(filename, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  for (const ext of extensions) {\n    if (yield { resolution: new URL(filename + ext, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  return status\n}\n\nexports.directory = function* (dirname, parentURL, opts = {}) {\n  let directoryURL\n\n  if (\n    dirname[dirname.length - 1] === '/' ||\n    dirname[dirname.length - 1] === '\\\\'\n  ) {\n    directoryURL = new URL(dirname, parentURL)\n  } else {\n    directoryURL = new URL(dirname + '/', parentURL)\n  }\n\n  const info = yield { package: new URL('package.json', directoryURL) }\n\n  if (info) {\n    if (info.exports) {\n      return yield* exports.packageExports(\n        directoryURL,\n        '.',\n        info.exports,\n        opts\n      )\n    }\n\n    if (typeof info.main === 'string' && info.main !== '') {\n      const status = yield* exports.file(info.main, directoryURL, false, opts)\n\n      if (status === RESOLVED) return status\n\n      return yield* exports.directory(info.main, directoryURL, opts)\n    }\n  }\n\n  return yield* exports.file('index', directoryURL, true, opts)\n}\n\n// https://infra.spec.whatwg.org/#ascii-upper-alpha\nfunction isASCIIUpperAlpha(c) {\n  return c >= 0x41 && c <= 0x5a\n}\n\n// https://infra.spec.whatwg.org/#ascii-lower-alpha\nfunction isASCIILowerAlpha(c) {\n  return c >= 0x61 && c <= 0x7a\n}\n\n// https://infra.spec.whatwg.org/#ascii-alpha\nfunction isASCIIAlpha(c) {\n  return isASCIIUpperAlpha(c) || isASCIILowerAlpha(c)\n}\n\n// https://url.spec.whatwg.org/#windows-drive-letter\nexports.isWindowsDriveLetter = function isWindowsDriveLetter(input) {\n  return (\n    input.length >= 2 &&\n    isASCIIAlpha(input.charCodeAt(0)) &&\n    (input.charCodeAt(1) === 0x3a || input.charCodeAt(1) === 0x7c)\n  )\n}\n\n// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter\nexports.startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(\n  input\n) {\n  return (\n    input.length >= 2 &&\n    exports.isWindowsDriveLetter(input) &&\n    (input.length === 2 ||\n      input.charCodeAt(2) === 0x2f ||\n      input.charCodeAt(2) === 0x5c ||\n      input.charCodeAt(2) === 0x3f ||\n      input.charCodeAt(2) === 0x23)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyw0RUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDZDQUE2QztBQUMzRCxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx1Q0FBdUM7QUFDbEQsVUFBVSxpQkFBaUI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFB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QUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvVGFydW5TaW5naC9Eb2N1bWVudHMvc3RlbGxlci9mcm9udGVuZC9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHNhdGlzZmllcyB9ID0gcmVxdWlyZSgnYmFyZS1zZW12ZXInKVxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9saWIvZXJyb3JzJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gcmVzb2x2ZShcbiAgc3BlY2lmaWVyLFxuICBwYXJlbnRVUkwsXG4gIG9wdHMsXG4gIHJlYWRQYWNrYWdlXG4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRQYWNrYWdlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVhZFBhY2thZ2UgPSBkZWZhdWx0UmVhZFBhY2thZ2VcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5tb2R1bGUoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgICAgIGxldCBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoKVxuXG4gICAgICB3aGlsZSAobmV4dC5kb25lICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZVxuXG4gICAgICAgIGlmICh2YWx1ZS5wYWNrYWdlKSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHJlYWRQYWNrYWdlKHZhbHVlLnBhY2thZ2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dCh5aWVsZCB2YWx1ZS5yZXNvbHV0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfSxcblxuICAgIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5tb2R1bGUoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgICAgIGxldCBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoKVxuXG4gICAgICB3aGlsZSAobmV4dC5kb25lICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZVxuXG4gICAgICAgIGlmICh2YWx1ZS5wYWNrYWdlKSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KGF3YWl0IHJlYWRQYWNrYWdlKHZhbHVlLnBhY2thZ2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dCh5aWVsZCB2YWx1ZS5yZXNvbHV0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWFkUGFja2FnZSgpIHtcbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gTm8gcmVzb2x1dGlvbiBjYW5kaWRhdGUgd2FzIHlpZWxkZWRcbmNvbnN0IFVOUkVTT0xWRUQgPSAweDBcbi8vIEF0IGxlYXN0IDEgcmVzb2x1dGlvbiBjYW5kaWRhdGUgd2FzIHlpZWxkZWRcbmNvbnN0IFlJRUxERUQgPSAweDFcbi8vIEF0IGxlYXN0IDEgcmVzb2x1dGlvbiBjYW5kaWRhdGUgd2FzIHlpZWxkZWQgYW5kIHJlc29sdmVkXG5jb25zdCBSRVNPTFZFRCA9IFlJRUxERUQgfCAweDJcblxuZXhwb3J0cy5jb25zdGFudHMgPSB7XG4gIFVOUkVTT0xWRUQsXG4gIFlJRUxERUQsXG4gIFJFU09MVkVEXG59XG5cbmV4cG9ydHMubW9kdWxlID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsLCBpbXBvcnRzID0gbnVsbCB9ID0gb3B0c1xuXG4gIGlmIChleHBvcnRzLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoc3BlY2lmaWVyKSkge1xuICAgIHNwZWNpZmllciA9ICcvJyArIHNwZWNpZmllclxuICB9XG5cbiAgbGV0IHN0YXR1c1xuXG4gIGlmIChyZXNvbHV0aW9ucykge1xuICAgIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnByZXJlc29sdmVkKHNwZWNpZmllciwgcmVzb2x1dGlvbnMsIHBhcmVudFVSTCwgb3B0cylcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnVybChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHMoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuXG4gIGlmIChcbiAgICBzcGVjaWZpZXIgPT09ICcuJyB8fFxuICAgIHNwZWNpZmllciA9PT0gJy4uJyB8fFxuICAgIHNwZWNpZmllclswXSA9PT0gJy8nIHx8XG4gICAgc3BlY2lmaWVyWzBdID09PSAnXFxcXCcgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi8nKSB8fFxuICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuXFxcXCcpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uLycpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uXFxcXCcpXG4gICkge1xuICAgIGlmIChpbXBvcnRzKSB7XG4gICAgICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICAgIHNwZWNpZmllcixcbiAgICAgICAgaW1wb3J0cyxcbiAgICAgICAgcGFyZW50VVJMLFxuICAgICAgICB0cnVlLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5maWxlKHNwZWNpZmllciwgcGFyZW50VVJMLCBmYWxzZSwgb3B0cylcblxuICAgIGlmIChzdGF0dXMgPT09IFJFU09MVkVEKSByZXR1cm4gc3RhdHVzXG5cbiAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuICB9XG5cbiAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2Uoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG59XG5cbmV4cG9ydHMudXJsID0gZnVuY3Rpb24qICh1cmwsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgaW1wb3J0cyA9IG51bGwgfSA9IG9wdHNcblxuICBsZXQgcmVzb2x1dGlvblxuICB0cnkge1xuICAgIHJlc29sdXRpb24gPSBuZXcgVVJMKHVybClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFVOUkVTT0xWRURcbiAgfVxuXG4gIGlmIChpbXBvcnRzKSB7XG4gICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZUltcG9ydHNFeHBvcnRzKFxuICAgICAgcmVzb2x1dGlvbi5ocmVmLFxuICAgICAgaW1wb3J0cyxcbiAgICAgIHBhcmVudFVSTCxcbiAgICAgIHRydWUsXG4gICAgICBvcHRzXG4gICAgKVxuXG4gICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICB9XG5cbiAgaWYgKHJlc29sdXRpb24ucHJvdG9jb2wgPT09ICdub2RlOicpIHtcbiAgICBjb25zdCBzcGVjaWZpZXIgPSByZXNvbHV0aW9uLnBhdGhuYW1lXG5cbiAgICBpZiAoXG4gICAgICBzcGVjaWZpZXIgPT09ICcuJyB8fFxuICAgICAgc3BlY2lmaWVyID09PSAnLi4nIHx8XG4gICAgICBzcGVjaWZpZXJbMF0gPT09ICcvJyB8fFxuICAgICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4vJykgfHxcbiAgICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuLi8nKVxuICAgICkge1xuICAgICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgICAgYE1vZHVsZSBzcGVjaWZpZXIgJyR7dXJsfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlKHNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzKVxuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCB7IHJlc29sdXRpb24gfVxuXG4gIHJldHVybiByZXNvbHZlZCA/IFJFU09MVkVEIDogWUlFTERFRFxufVxuXG5leHBvcnRzLnByZXJlc29sdmVkID0gZnVuY3Rpb24qIChzcGVjaWZpZXIsIHJlc29sdXRpb25zLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBjb25zdCBpbXBvcnRzID0gcmVzb2x1dGlvbnNbcGFyZW50VVJMLmhyZWZdXG5cbiAgaWYgKHR5cGVvZiBpbXBvcnRzID09PSAnb2JqZWN0JyAmJiBpbXBvcnRzICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyhcbiAgICAgIHNwZWNpZmllcixcbiAgICAgIGltcG9ydHMsXG4gICAgICBwYXJlbnRVUkwsXG4gICAgICB0cnVlLFxuICAgICAgb3B0c1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMucGFja2FnZSA9IGZ1bmN0aW9uKiAocGFja2FnZVNwZWNpZmllciwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBidWlsdGlucyA9IFtdIH0gPSBvcHRzXG5cbiAgaWYgKHBhY2thZ2VTcGVjaWZpZXIgPT09ICcnKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke3BhY2thZ2VTcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgKVxuICB9XG5cbiAgbGV0IHBhY2thZ2VOYW1lXG5cbiAgaWYgKHBhY2thZ2VTcGVjaWZpZXJbMF0gIT09ICdAJykge1xuICAgIHBhY2thZ2VOYW1lID0gcGFja2FnZVNwZWNpZmllci5zcGxpdCgnLycsIDEpLmpvaW4oKVxuICB9IGVsc2Uge1xuICAgIGlmICghcGFja2FnZVNwZWNpZmllci5pbmNsdWRlcygnLycpKSB7XG4gICAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSKFxuICAgICAgICBgTW9kdWxlIHNwZWNpZmllciAnJHtwYWNrYWdlU3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgICAgKVxuICAgIH1cblxuICAgIHBhY2thZ2VOYW1lID0gcGFja2FnZVNwZWNpZmllci5zcGxpdCgnLycsIDIpLmpvaW4oJy8nKVxuICB9XG5cbiAgaWYgKFxuICAgIHBhY2thZ2VOYW1lWzBdID09PSAnLicgfHxcbiAgICBwYWNrYWdlTmFtZS5pbmNsdWRlcygnXFxcXCcpIHx8XG4gICAgcGFja2FnZU5hbWUuaW5jbHVkZXMoJyUnKVxuICApIHtcbiAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSKFxuICAgICAgYE1vZHVsZSBzcGVjaWZpZXIgJyR7cGFja2FnZVNwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICApXG4gIH1cblxuICBsZXQgc3RhdHVzXG5cbiAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMuYnVpbHRpblRhcmdldChwYWNrYWdlU3BlY2lmaWVyLCBudWxsLCBidWlsdGlucywgb3B0cylcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgbGV0IHBhY2thZ2VTdWJwYXRoID0gJy4nICsgcGFja2FnZVNwZWNpZmllci5zdWJzdHJpbmcocGFja2FnZU5hbWUubGVuZ3RoKVxuXG4gIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VTZWxmKFxuICAgIHBhY2thZ2VOYW1lLFxuICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgIHBhcmVudFVSTCxcbiAgICBvcHRzXG4gIClcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgcGFyZW50VVJMID0gbmV3IFVSTChwYXJlbnRVUkwuaHJlZilcblxuICBkbyB7XG4gICAgY29uc3QgcGFja2FnZVVSTCA9IG5ldyBVUkwoJ25vZGVfbW9kdWxlcy8nICsgcGFja2FnZU5hbWUgKyAnLycsIHBhcmVudFVSTClcblxuICAgIHBhcmVudFVSTC5wYXRobmFtZSA9IHBhcmVudFVSTC5wYXRobmFtZS5zdWJzdHJpbmcoXG4gICAgICAwLFxuICAgICAgcGFyZW50VVJMLnBhdGhuYW1lLmxhc3RJbmRleE9mKCcvJylcbiAgICApXG5cbiAgICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBwYWNrYWdlVVJMKSB9XG5cbiAgICBpZiAoaW5mbykge1xuICAgICAgaWYgKGluZm8uZW5naW5lcykgZXhwb3J0cy52YWxpZGF0ZUVuZ2luZXMocGFja2FnZVVSTCwgaW5mby5lbmdpbmVzLCBvcHRzKVxuXG4gICAgICBpZiAoaW5mby5leHBvcnRzKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlRXhwb3J0cyhcbiAgICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgICAgICAgIGluZm8uZXhwb3J0cyxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHBhY2thZ2VTdWJwYXRoID09PSAnLicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvLm1haW4gPT09ICdzdHJpbmcnICYmIGluZm8ubWFpbiAhPT0gJycpIHtcbiAgICAgICAgICBwYWNrYWdlU3VicGF0aCA9IGluZm8ubWFpblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5maWxlKCdpbmRleCcsIHBhY2thZ2VVUkwsIHRydWUsIG9wdHMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdHVzID0geWllbGQqIGV4cG9ydHMuZmlsZShwYWNrYWdlU3VicGF0aCwgcGFja2FnZVVSTCwgZmFsc2UsIG9wdHMpXG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFJFU09MVkVEKSByZXR1cm4gc3RhdHVzXG5cbiAgICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3RvcnkocGFja2FnZVN1YnBhdGgsIHBhY2thZ2VVUkwsIG9wdHMpXG4gICAgfVxuICB9IHdoaWxlIChwYXJlbnRVUkwucGF0aG5hbWUgIT09ICcnICYmIHBhcmVudFVSTC5wYXRobmFtZSAhPT0gJy8nKVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMucGFja2FnZVNlbGYgPSBmdW5jdGlvbiogKFxuICBwYWNrYWdlTmFtZSxcbiAgcGFja2FnZVN1YnBhdGgsXG4gIHBhcmVudFVSTCxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgZm9yIChjb25zdCBwYWNrYWdlVVJMIG9mIGV4cG9ydHMubG9va3VwUGFja2FnZVNjb3BlKHBhcmVudFVSTCwgb3B0cykpIHtcbiAgICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBwYWNrYWdlVVJMIH1cblxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpZiAoaW5mby5uYW1lICE9PSBwYWNrYWdlTmFtZSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIGlmIChpbmZvLmV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2VFeHBvcnRzKFxuICAgICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgICAgcGFja2FnZVN1YnBhdGgsXG4gICAgICAgICAgaW5mby5leHBvcnRzLFxuICAgICAgICAgIG9wdHNcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAocGFja2FnZVN1YnBhdGggPT09ICcuJykge1xuICAgICAgICBpZiAodHlwZW9mIGluZm8ubWFpbiA9PT0gJ3N0cmluZycgJiYgaW5mby5tYWluICE9PSAnJykge1xuICAgICAgICAgIHBhY2thZ2VTdWJwYXRoID0gaW5mby5tYWluXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmZpbGUoJ2luZGV4JywgcGFja2FnZVVSTCwgdHJ1ZSwgb3B0cylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5maWxlKFxuICAgICAgICBwYWNrYWdlU3VicGF0aCxcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG9wdHNcbiAgICAgIClcblxuICAgICAgaWYgKHN0YXR1cyA9PT0gUkVTT0xWRUQpIHJldHVybiBzdGF0dXNcblxuICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLmRpcmVjdG9yeShwYWNrYWdlU3VicGF0aCwgcGFja2FnZVVSTCwgb3B0cylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5SRVNPTFZFRFxufVxuXG5leHBvcnRzLnBhY2thZ2VFeHBvcnRzID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZVVSTCxcbiAgc3VicGF0aCxcbiAgcGFja2FnZUV4cG9ydHMsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGlmIChzdWJwYXRoID09PSAnLicpIHtcbiAgICBsZXQgbWFpbkV4cG9ydFxuXG4gICAgaWYgKHR5cGVvZiBwYWNrYWdlRXhwb3J0cyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShwYWNrYWdlRXhwb3J0cykpIHtcbiAgICAgIG1haW5FeHBvcnQgPSBwYWNrYWdlRXhwb3J0c1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhY2thZ2VFeHBvcnRzID09PSAnb2JqZWN0JyAmJiBwYWNrYWdlRXhwb3J0cyAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhY2thZ2VFeHBvcnRzKVxuXG4gICAgICBpZiAoa2V5cy5zb21lKChrZXkpID0+IGtleS5zdGFydHNXaXRoKCcuJykpKSB7XG4gICAgICAgIGlmICgnLicgaW4gcGFja2FnZUV4cG9ydHMpIG1haW5FeHBvcnQgPSBwYWNrYWdlRXhwb3J0c1snLiddXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluRXhwb3J0ID0gcGFja2FnZUV4cG9ydHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFpbkV4cG9ydCkge1xuICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZVRhcmdldChcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgbWFpbkV4cG9ydCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG9wdHNcbiAgICAgIClcblxuICAgICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFja2FnZUV4cG9ydHMgPT09ICdvYmplY3QnICYmIHBhY2thZ2VFeHBvcnRzICE9PSBudWxsKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhY2thZ2VFeHBvcnRzKVxuXG4gICAgaWYgKGtleXMuZXZlcnkoKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJy4nKSkpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyhcbiAgICAgICAgc3VicGF0aCxcbiAgICAgICAgcGFja2FnZUV4cG9ydHMsXG4gICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICB9XG4gIH1cblxuICBwYWNrYWdlVVJMID0gbmV3IFVSTCgncGFja2FnZS5qc29uJywgcGFja2FnZVVSTClcblxuICB0aHJvdyBlcnJvcnMuUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRChcbiAgICBgUGFja2FnZSBzdWJwYXRoICcke3N1YnBhdGh9JyBpcyBub3QgZGVmaW5lZCBieSBcImV4cG9ydHNcIiBpbiAnJHtwYWNrYWdlVVJMfSdgXG4gIClcbn1cblxuZXhwb3J0cy5wYWNrYWdlSW1wb3J0cyA9IGZ1bmN0aW9uKiAoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGltcG9ydHMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKHNwZWNpZmllciA9PT0gJyMnIHx8IHNwZWNpZmllci5zdGFydHNXaXRoKCcjLycpKSB7XG4gICAgdGhyb3cgZXJyb3JzLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUihcbiAgICAgIGBNb2R1bGUgc3BlY2lmaWVyICcke3NwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIGludGVybmFsIGltcG9ydHMgc3BlY2lmaWVyYFxuICAgIClcbiAgfVxuXG4gIGZvciAoY29uc3QgcGFja2FnZVVSTCBvZiBleHBvcnRzLmxvb2t1cFBhY2thZ2VTY29wZShwYXJlbnRVUkwsIG9wdHMpKSB7XG4gICAgY29uc3QgaW5mbyA9IHlpZWxkIHsgcGFja2FnZTogcGFja2FnZVVSTCB9XG5cbiAgICBpZiAoaW5mbykge1xuICAgICAgaWYgKGluZm8uaW1wb3J0cykge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCogZXhwb3J0cy5wYWNrYWdlSW1wb3J0c0V4cG9ydHMoXG4gICAgICAgICAgc3BlY2lmaWVyLFxuICAgICAgICAgIGluZm8uaW1wb3J0cyxcbiAgICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgb3B0c1xuICAgICAgICApXG5cbiAgICAgICAgaWYgKHN0YXR1cykgcmV0dXJuIHN0YXR1c1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuUEFDS0FHRV9JTVBPUlRfTk9UX0RFRklORUQoXG4gICAgICAgICAgYFBhY2thZ2UgaW1wb3J0IHNwZWNpZmllciAnJHtzcGVjaWZpZXJ9JyBpcyBub3QgZGVmaW5lZCBieSBcImltcG9ydHNcIiBpbiAnJHtwYWNrYWdlVVJMfSdgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoaW1wb3J0cykge1xuICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VJbXBvcnRzRXhwb3J0cyhcbiAgICAgIHNwZWNpZmllcixcbiAgICAgIGltcG9ydHMsXG4gICAgICBwYXJlbnRVUkwsXG4gICAgICB0cnVlLFxuICAgICAgb3B0c1xuICAgIClcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMucGFja2FnZUltcG9ydHNFeHBvcnRzID0gZnVuY3Rpb24qIChcbiAgbWF0Y2hLZXksXG4gIG1hdGNoT2JqZWN0LFxuICBwYWNrYWdlVVJMLFxuICBpc0ltcG9ydHMsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGlmIChtYXRjaEtleSBpbiBtYXRjaE9iamVjdCAmJiAhbWF0Y2hLZXkuaW5jbHVkZXMoJyonKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IG1hdGNoT2JqZWN0W21hdGNoS2V5XVxuXG4gICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2VUYXJnZXQoXG4gICAgICBwYWNrYWdlVVJMLFxuICAgICAgdGFyZ2V0LFxuICAgICAgbnVsbCxcbiAgICAgIGlzSW1wb3J0cyxcbiAgICAgIG9wdHNcbiAgICApXG4gIH1cblxuICBjb25zdCBleHBhbnNpb25LZXlzID0gT2JqZWN0LmtleXMobWF0Y2hPYmplY3QpXG4gICAgLmZpbHRlcigoa2V5KSA9PiBrZXkuaW5jbHVkZXMoJyonKSlcbiAgICAuc29ydChleHBvcnRzLnBhdHRlcm5LZXlDb21wYXJlKVxuXG4gIGZvciAoY29uc3QgZXhwYW5zaW9uS2V5IG9mIGV4cGFuc2lvbktleXMpIHtcbiAgICBjb25zdCBwYXR0ZXJuSW5kZXggPSBleHBhbnNpb25LZXkuaW5kZXhPZignKicpXG4gICAgY29uc3QgcGF0dGVybkJhc2UgPSBleHBhbnNpb25LZXkuc3Vic3RyaW5nKDAsIHBhdHRlcm5JbmRleClcblxuICAgIGlmIChtYXRjaEtleS5zdGFydHNXaXRoKHBhdHRlcm5CYXNlKSAmJiBtYXRjaEtleSAhPT0gcGF0dGVybkJhc2UpIHtcbiAgICAgIGNvbnN0IHBhdHRlcm5UcmFpbGVyID0gZXhwYW5zaW9uS2V5LnN1YnN0cmluZyhwYXR0ZXJuSW5kZXggKyAxKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHBhdHRlcm5UcmFpbGVyID09PSAnJyB8fFxuICAgICAgICAobWF0Y2hLZXkuZW5kc1dpdGgocGF0dGVyblRyYWlsZXIpICYmXG4gICAgICAgICAgbWF0Y2hLZXkubGVuZ3RoID49IGV4cGFuc2lvbktleS5sZW5ndGgpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbWF0Y2hPYmplY3RbZXhwYW5zaW9uS2V5XVxuXG4gICAgICAgIGNvbnN0IHBhdHRlcm5NYXRjaCA9IG1hdGNoS2V5LnN1YnN0cmluZyhcbiAgICAgICAgICBwYXR0ZXJuQmFzZS5sZW5ndGgsXG4gICAgICAgICAgbWF0Y2hLZXkubGVuZ3RoIC0gcGF0dGVyblRyYWlsZXIubGVuZ3RoXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZVRhcmdldChcbiAgICAgICAgICBwYWNrYWdlVVJMLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXR0ZXJuTWF0Y2gsXG4gICAgICAgICAgaXNJbXBvcnRzLFxuICAgICAgICAgIG9wdHNcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMudmFsaWRhdGVFbmdpbmVzID0gZnVuY3Rpb24gdmFsaWRhdGVFbmdpbmVzKFxuICBwYWNrYWdlVVJMLFxuICBwYWNrYWdlRW5naW5lcyxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgY29uc3QgeyBlbmdpbmVzID0ge30gfSA9IG9wdHNcblxuICBmb3IgKGNvbnN0IFtlbmdpbmUsIHJhbmdlXSBvZiBPYmplY3QuZW50cmllcyhwYWNrYWdlRW5naW5lcykpIHtcbiAgICBpZiAoZW5naW5lIGluIGVuZ2luZXMpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBlbmdpbmVzW2VuZ2luZV1cblxuICAgICAgaWYgKCFzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UpKSB7XG4gICAgICAgIHBhY2thZ2VVUkwgPSBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBwYWNrYWdlVVJMKVxuXG4gICAgICAgIHRocm93IGVycm9ycy5VTlNVUFBPUlRFRF9FTkdJTkUoXG4gICAgICAgICAgYFBhY2thZ2Ugbm90IGNvbXBhdGlibGUgd2l0aCBlbmdpbmUgJyR7ZW5naW5lfScgJHt2ZXJzaW9ufSwgcmVxdWlyZXMgcmFuZ2UgJyR7cmFuZ2V9JyBkZWZpbmVkIGJ5IFwiZW5naW5lc1wiIGluICcke3BhY2thZ2VVUkx9J2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnBhdHRlcm5LZXlDb21wYXJlID0gZnVuY3Rpb24gcGF0dGVybktleUNvbXBhcmUoa2V5QSwga2V5Qikge1xuICBjb25zdCBwYXR0ZXJuSW5kZXhBID0ga2V5QS5pbmRleE9mKCcqJylcbiAgY29uc3QgcGF0dGVybkluZGV4QiA9IGtleUIuaW5kZXhPZignKicpXG4gIGNvbnN0IGJhc2VMZW5ndGhBID0gcGF0dGVybkluZGV4QSA9PT0gLTEgPyBrZXlBLmxlbmd0aCA6IHBhdHRlcm5JbmRleEEgKyAxXG4gIGNvbnN0IGJhc2VMZW5ndGhCID0gcGF0dGVybkluZGV4QiA9PT0gLTEgPyBrZXlCLmxlbmd0aCA6IHBhdHRlcm5JbmRleEIgKyAxXG4gIGlmIChiYXNlTGVuZ3RoQSA+IGJhc2VMZW5ndGhCKSByZXR1cm4gLTFcbiAgaWYgKGJhc2VMZW5ndGhCID4gYmFzZUxlbmd0aEEpIHJldHVybiAxXG4gIGlmIChwYXR0ZXJuSW5kZXhBID09PSAtMSkgcmV0dXJuIDFcbiAgaWYgKHBhdHRlcm5JbmRleEIgPT09IC0xKSByZXR1cm4gLTFcbiAgaWYgKGtleUEubGVuZ3RoID4ga2V5Qi5sZW5ndGgpIHJldHVybiAtMVxuICBpZiAoa2V5Qi5sZW5ndGggPiBrZXlBLmxlbmd0aCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuZXhwb3J0cy5wYWNrYWdlVGFyZ2V0ID0gZnVuY3Rpb24qIChcbiAgcGFja2FnZVVSTCxcbiAgdGFyZ2V0LFxuICBwYXR0ZXJuTWF0Y2gsXG4gIGlzSW1wb3J0cyxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgY29uc3QgeyBjb25kaXRpb25zID0gW10sIG1hdGNoZWRDb25kaXRpb25zID0gW10gfSA9IG9wdHNcblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXRhcmdldC5zdGFydHNXaXRoKCcuLycpICYmICFpc0ltcG9ydHMpIHtcbiAgICAgIHBhY2thZ2VVUkwgPSBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBwYWNrYWdlVVJMKVxuXG4gICAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9QQUNLQUdFX1RBUkdFVChcbiAgICAgICAgYEludmFsaWQgdGFyZ2V0ICcke3RhcmdldH0nIGRlZmluZWQgYnkgXCJleHBvcnRzXCIgaW4gJyR7cGFja2FnZVVSTH0nYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwYXR0ZXJuTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5yZXBsYWNlQWxsKCcqJywgcGF0dGVybk1hdGNoKVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnVybCh0YXJnZXQsIHBhY2thZ2VVUkwsIG9wdHMpXG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgICBpZiAoXG4gICAgICB0YXJnZXQgPT09ICcuJyB8fFxuICAgICAgdGFyZ2V0ID09PSAnLi4nIHx8XG4gICAgICB0YXJnZXRbMF0gPT09ICcvJyB8fFxuICAgICAgdGFyZ2V0LnN0YXJ0c1dpdGgoJy4vJykgfHxcbiAgICAgIHRhcmdldC5zdGFydHNXaXRoKCcuLi8nKVxuICAgICkge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCB7IHJlc29sdXRpb246IG5ldyBVUkwodGFyZ2V0LCBwYWNrYWdlVVJMKSB9XG5cbiAgICAgIHJldHVybiByZXNvbHZlZCA/IFJFU09MVkVEIDogWUlFTERFRFxuICAgIH1cblxuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5wYWNrYWdlKHRhcmdldCwgcGFja2FnZVVSTCwgb3B0cylcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICBmb3IgKGNvbnN0IHRhcmdldFZhbHVlIG9mIHRhcmdldCkge1xuICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZVRhcmdldChcbiAgICAgICAgcGFja2FnZVVSTCxcbiAgICAgICAgdGFyZ2V0VmFsdWUsXG4gICAgICAgIHBhdHRlcm5NYXRjaCxcbiAgICAgICAgaXNJbXBvcnRzLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgbGV0IHN0YXR1cyA9IFVOUkVTT0xWRURcblxuICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbiwgdGFyZ2V0VmFsdWUsIHN1YnNldF0gb2YgZXhwb3J0cy5jb25kaXRpb25NYXRjaGVzKFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29uZGl0aW9ucyxcbiAgICAgIG9wdHNcbiAgICApKSB7XG4gICAgICBtYXRjaGVkQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbilcblxuICAgICAgc3RhdHVzIHw9IHlpZWxkKiBleHBvcnRzLnBhY2thZ2VUYXJnZXQoXG4gICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgIHRhcmdldFZhbHVlLFxuICAgICAgICBwYXR0ZXJuTWF0Y2gsXG4gICAgICAgIGlzSW1wb3J0cyxcbiAgICAgICAgeyAuLi5vcHRzLCBjb25kaXRpb25zOiBzdWJzZXQgfVxuICAgICAgKVxuXG4gICAgICBtYXRjaGVkQ29uZGl0aW9ucy5wb3AoKVxuICAgIH1cblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMuYnVpbHRpblRhcmdldCA9IGZ1bmN0aW9uKiAoXG4gIHBhY2thZ2VTcGVjaWZpZXIsXG4gIHBhY2thZ2VWZXJzaW9uLFxuICB0YXJnZXQsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGNvbnN0IHtcbiAgICBidWlsdGluUHJvdG9jb2wgPSAnYnVpbHRpbjonLFxuICAgIGNvbmRpdGlvbnMgPSBbXSxcbiAgICBtYXRjaGVkQ29uZGl0aW9ucyA9IFtdXG4gIH0gPSBvcHRzXG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdGFyZ2V0UGFydHMgPSB0YXJnZXQuc3BsaXQoJ0AnKVxuXG4gICAgbGV0IHRhcmdldE5hbWVcbiAgICBsZXQgdGFyZ2V0VmVyc2lvblxuXG4gICAgaWYgKHRhcmdldFswXSAhPT0gJ0AnKSB7XG4gICAgICB0YXJnZXROYW1lID0gdGFyZ2V0UGFydHNbMF1cbiAgICAgIHRhcmdldFZlcnNpb24gPSB0YXJnZXRQYXJ0c1sxXSB8fCBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldE5hbWUgPSB0YXJnZXRQYXJ0cy5zbGljZSgwLCAyKS5qb2luKCdAJylcbiAgICAgIHRhcmdldFZlcnNpb24gPSB0YXJnZXRQYXJ0c1syXSB8fCBudWxsXG4gICAgfVxuXG4gICAgaWYgKHBhY2thZ2VTcGVjaWZpZXIgPT09IHRhcmdldE5hbWUpIHtcbiAgICAgIGlmIChwYWNrYWdlVmVyc2lvbiA9PT0gbnVsbCAmJiB0YXJnZXRWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQge1xuICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYnVpbHRpblByb3RvY29sICsgcGFja2FnZVNwZWNpZmllcilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZCA/IFJFU09MVkVEIDogWUlFTERFRFxuICAgICAgfVxuXG4gICAgICBsZXQgdmVyc2lvbiA9IG51bGxcblxuICAgICAgaWYgKHBhY2thZ2VWZXJzaW9uID09PSBudWxsKSB7XG4gICAgICAgIHZlcnNpb24gPSB0YXJnZXRWZXJzaW9uXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldFZlcnNpb24gPT09IG51bGwgfHwgcGFja2FnZVZlcnNpb24gPT09IHRhcmdldFZlcnNpb24pIHtcbiAgICAgICAgdmVyc2lvbiA9IHBhY2thZ2VWZXJzaW9uXG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQge1xuICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoXG4gICAgICAgICAgICBidWlsdGluUHJvdG9jb2wgKyBwYWNrYWdlU3BlY2lmaWVyICsgJ0AnICsgdmVyc2lvblxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZCA/IFJFU09MVkVEIDogWUlFTERFRFxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICBmb3IgKGNvbnN0IHRhcmdldFZhbHVlIG9mIHRhcmdldCkge1xuICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMuYnVpbHRpblRhcmdldChcbiAgICAgICAgcGFja2FnZVNwZWNpZmllcixcbiAgICAgICAgcGFja2FnZVZlcnNpb24sXG4gICAgICAgIHRhcmdldFZhbHVlLFxuICAgICAgICBvcHRzXG4gICAgICApXG5cbiAgICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgbGV0IHN0YXR1cyA9IFVOUkVTT0xWRURcblxuICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbiwgdGFyZ2V0VmFsdWUsIHN1YnNldF0gb2YgZXhwb3J0cy5jb25kaXRpb25NYXRjaGVzKFxuICAgICAgdGFyZ2V0LFxuICAgICAgY29uZGl0aW9ucyxcbiAgICAgIG9wdHNcbiAgICApKSB7XG4gICAgICBtYXRjaGVkQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbilcblxuICAgICAgc3RhdHVzIHw9IHlpZWxkKiBleHBvcnRzLmJ1aWx0aW5UYXJnZXQoXG4gICAgICAgIHBhY2thZ2VTcGVjaWZpZXIsXG4gICAgICAgIHBhY2thZ2VWZXJzaW9uLFxuICAgICAgICB0YXJnZXRWYWx1ZSxcbiAgICAgICAgeyAuLi5vcHRzLCBjb25kaXRpb25zOiBzdWJzZXQgfVxuICAgICAgKVxuXG4gICAgICBtYXRjaGVkQ29uZGl0aW9ucy5wb3AoKVxuICAgIH1cblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMuY29uZGl0aW9uTWF0Y2hlcyA9IGZ1bmN0aW9uKiBjb25kaXRpb25NYXRjaGVzKFxuICB0YXJnZXQsXG4gIGNvbmRpdGlvbnMsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGlmIChjb25kaXRpb25zLmV2ZXJ5KChjb25kaXRpb24pID0+IHR5cGVvZiBjb25kaXRpb24gPT09ICdzdHJpbmcnKSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpXG5cbiAgICBmb3IgKGNvbnN0IGNvbmRpdGlvbiBvZiBrZXlzKSB7XG4gICAgICBpZiAoY29uZGl0aW9uID09PSAnZGVmYXVsdCcgfHwgY29uZGl0aW9ucy5pbmNsdWRlcyhjb25kaXRpb24pKSB7XG4gICAgICAgIHlpZWxkIFtjb25kaXRpb24sIHRhcmdldFtjb25kaXRpb25dLCBjb25kaXRpb25zXVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgeWllbGRlZCA9IGZhbHNlXG5cbiAgZm9yIChjb25zdCBzdWJzZXQgb2YgY29uZGl0aW9ucykge1xuICAgIGlmICh5aWVsZCogY29uZGl0aW9uTWF0Y2hlcyh0YXJnZXQsIHN1YnNldCwgb3B0cykpIHtcbiAgICAgIHlpZWxkZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHlpZWxkZWRcbn1cblxuZXhwb3J0cy5sb29rdXBQYWNrYWdlU2NvcGUgPSBmdW5jdGlvbiogbG9va3VwUGFja2FnZVNjb3BlKHVybCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgcmVzb2x1dGlvbnMgPSBudWxsIH0gPSBvcHRzXG5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgZm9yIChjb25zdCB7IHJlc29sdXRpb24gfSBvZiBleHBvcnRzLnByZXJlc29sdmVkKFxuICAgICAgJyNwYWNrYWdlJyxcbiAgICAgIHJlc29sdXRpb25zLFxuICAgICAgdXJsLFxuICAgICAgb3B0c1xuICAgICkpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uKSByZXR1cm4geWllbGQgcmVzb2x1dGlvblxuICAgIH1cblxuICAgIC8vIEludGVybmFsIHByZXJlc29sdXRpb24gcGF0aCwgZG8gbm90IGRlcGVuZCBvbiB0aGlzISBJdCB3aWxsIGJlIHJlbW92ZWQgd2l0aG91dFxuICAgIC8vIHdhcm5pbmcuXG4gICAgZm9yIChjb25zdCB7IHJlc29sdXRpb24gfSBvZiBleHBvcnRzLnByZXJlc29sdmVkKFxuICAgICAgJ2JhcmU6cGFja2FnZScsXG4gICAgICByZXNvbHV0aW9ucyxcbiAgICAgIHVybCxcbiAgICAgIG9wdHNcbiAgICApKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbikgcmV0dXJuIHlpZWxkIHJlc29sdXRpb25cbiAgICB9XG4gIH1cblxuICBjb25zdCBzY29wZVVSTCA9IG5ldyBVUkwodXJsLmhyZWYpXG5cbiAgZG8ge1xuICAgIGlmIChzY29wZVVSTC5wYXRobmFtZS5lbmRzV2l0aCgnL25vZGVfbW9kdWxlcycpKSBicmVha1xuXG4gICAgeWllbGQgbmV3IFVSTCgncGFja2FnZS5qc29uJywgc2NvcGVVUkwpXG5cbiAgICBzY29wZVVSTC5wYXRobmFtZSA9IHNjb3BlVVJMLnBhdGhuYW1lLnN1YnN0cmluZyhcbiAgICAgIDAsXG4gICAgICBzY29wZVVSTC5wYXRobmFtZS5sYXN0SW5kZXhPZignLycpXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgc2NvcGVVUkwucGF0aG5hbWUubGVuZ3RoID09PSAzICYmXG4gICAgICBleHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyKHNjb3BlVVJMLnBhdGhuYW1lLnN1YnN0cmluZygxKSlcbiAgICApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9IHdoaWxlIChzY29wZVVSTC5wYXRobmFtZSAhPT0gJycgJiYgc2NvcGVVUkwucGF0aG5hbWUgIT09ICcvJylcbn1cblxuZXhwb3J0cy5maWxlID0gZnVuY3Rpb24qIChmaWxlbmFtZSwgcGFyZW50VVJMLCBpc0luZGV4LCBvcHRzID0ge30pIHtcbiAgaWYgKFxuICAgIGZpbGVuYW1lID09PSAnLicgfHxcbiAgICBmaWxlbmFtZSA9PT0gJy4uJyB8fFxuICAgIGZpbGVuYW1lW2ZpbGVuYW1lLmxlbmd0aCAtIDFdID09PSAnLycgfHxcbiAgICBmaWxlbmFtZVtmaWxlbmFtZS5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnXG4gICkge1xuICAgIHJldHVybiBVTlJFU09MVkVEXG4gIH1cblxuICBpZiAocGFyZW50VVJMLnByb3RvY29sID09PSAnZmlsZTonICYmIC8lMmZ8JTVjL2kudGVzdChmaWxlbmFtZSkpIHtcbiAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9NT0RVTEVfU1BFQ0lGSUVSKFxuICAgICAgYE1vZHVsZSBzcGVjaWZpZXIgJyR7ZmlsZW5hbWV9JyBpcyBpbnZhbGlkYFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHsgZXh0ZW5zaW9ucyA9IFtdIH0gPSBvcHRzXG5cbiAgbGV0IHN0YXR1cyA9IFVOUkVTT0xWRURcblxuICBpZiAoIWlzSW5kZXgpIHtcbiAgICBpZiAoeWllbGQgeyByZXNvbHV0aW9uOiBuZXcgVVJMKGZpbGVuYW1lLCBwYXJlbnRVUkwpIH0pIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cblxuICAgIHN0YXR1cyA9IFlJRUxERURcbiAgfVxuXG4gIGZvciAoY29uc3QgZXh0IG9mIGV4dGVuc2lvbnMpIHtcbiAgICBpZiAoeWllbGQgeyByZXNvbHV0aW9uOiBuZXcgVVJMKGZpbGVuYW1lICsgZXh0LCBwYXJlbnRVUkwpIH0pIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cblxuICAgIHN0YXR1cyA9IFlJRUxERURcbiAgfVxuXG4gIHJldHVybiBzdGF0dXNcbn1cblxuZXhwb3J0cy5kaXJlY3RvcnkgPSBmdW5jdGlvbiogKGRpcm5hbWUsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGxldCBkaXJlY3RvcnlVUkxcblxuICBpZiAoXG4gICAgZGlybmFtZVtkaXJuYW1lLmxlbmd0aCAtIDFdID09PSAnLycgfHxcbiAgICBkaXJuYW1lW2Rpcm5hbWUubGVuZ3RoIC0gMV0gPT09ICdcXFxcJ1xuICApIHtcbiAgICBkaXJlY3RvcnlVUkwgPSBuZXcgVVJMKGRpcm5hbWUsIHBhcmVudFVSTClcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3RvcnlVUkwgPSBuZXcgVVJMKGRpcm5hbWUgKyAnLycsIHBhcmVudFVSTClcbiAgfVxuXG4gIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIGRpcmVjdG9yeVVSTCkgfVxuXG4gIGlmIChpbmZvKSB7XG4gICAgaWYgKGluZm8uZXhwb3J0cykge1xuICAgICAgcmV0dXJuIHlpZWxkKiBleHBvcnRzLnBhY2thZ2VFeHBvcnRzKFxuICAgICAgICBkaXJlY3RvcnlVUkwsXG4gICAgICAgICcuJyxcbiAgICAgICAgaW5mby5leHBvcnRzLFxuICAgICAgICBvcHRzXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmZvLm1haW4gPT09ICdzdHJpbmcnICYmIGluZm8ubWFpbiAhPT0gJycpIHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLmZpbGUoaW5mby5tYWluLCBkaXJlY3RvcnlVUkwsIGZhbHNlLCBvcHRzKVxuXG4gICAgICBpZiAoc3RhdHVzID09PSBSRVNPTFZFRCkgcmV0dXJuIHN0YXR1c1xuXG4gICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KGluZm8ubWFpbiwgZGlyZWN0b3J5VVJMLCBvcHRzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB5aWVsZCogZXhwb3J0cy5maWxlKCdpbmRleCcsIGRpcmVjdG9yeVVSTCwgdHJ1ZSwgb3B0cylcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXVwcGVyLWFscGhhXG5mdW5jdGlvbiBpc0FTQ0lJVXBwZXJBbHBoYShjKSB7XG4gIHJldHVybiBjID49IDB4NDEgJiYgYyA8PSAweDVhXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS1sb3dlci1hbHBoYVxuZnVuY3Rpb24gaXNBU0NJSUxvd2VyQWxwaGEoYykge1xuICByZXR1cm4gYyA+PSAweDYxICYmIGMgPD0gMHg3YVxufVxuXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktYWxwaGFcbmZ1bmN0aW9uIGlzQVNDSUlBbHBoYShjKSB7XG4gIHJldHVybiBpc0FTQ0lJVXBwZXJBbHBoYShjKSB8fCBpc0FTQ0lJTG93ZXJBbHBoYShjKVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3dpbmRvd3MtZHJpdmUtbGV0dGVyXG5leHBvcnRzLmlzV2luZG93c0RyaXZlTGV0dGVyID0gZnVuY3Rpb24gaXNXaW5kb3dzRHJpdmVMZXR0ZXIoaW5wdXQpIHtcbiAgcmV0dXJuIChcbiAgICBpbnB1dC5sZW5ndGggPj0gMiAmJlxuICAgIGlzQVNDSUlBbHBoYShpbnB1dC5jaGFyQ29kZUF0KDApKSAmJlxuICAgIChpbnB1dC5jaGFyQ29kZUF0KDEpID09PSAweDNhIHx8IGlucHV0LmNoYXJDb2RlQXQoMSkgPT09IDB4N2MpXG4gIClcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzdGFydC13aXRoLWEtd2luZG93cy1kcml2ZS1sZXR0ZXJcbmV4cG9ydHMuc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoXG4gIGlucHV0XG4pIHtcbiAgcmV0dXJuIChcbiAgICBpbnB1dC5sZW5ndGggPj0gMiAmJlxuICAgIGV4cG9ydHMuaXNXaW5kb3dzRHJpdmVMZXR0ZXIoaW5wdXQpICYmXG4gICAgKGlucHV0Lmxlbmd0aCA9PT0gMiB8fFxuICAgICAgaW5wdXQuY2hhckNvZGVBdCgyKSA9PT0gMHgyZiB8fFxuICAgICAgaW5wdXQuY2hhckNvZGVBdCgyKSA9PT0gMHg1YyB8fFxuICAgICAgaW5wdXQuY2hhckNvZGVBdCgyKSA9PT0gMHgzZiB8fFxuICAgICAgaW5wdXQuY2hhckNvZGVBdCgyKSA9PT0gMHgyMylcbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-module-resolve/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bare-module-resolve/lib/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/bare-module-resolve/lib/errors.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = class ModuleResolveError extends Error {\n  constructor(msg, code, fn = ModuleResolveError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'ModuleResolveError'\n  }\n\n  static INVALID_MODULE_SPECIFIER(msg) {\n    return new ModuleResolveError(\n      msg,\n      'INVALID_MODULE_SPECIFIER',\n      ModuleResolveError.INVALID_MODULE_SPECIFIER\n    )\n  }\n\n  static INVALID_PACKAGE_TARGET(msg) {\n    return new ModuleResolveError(\n      msg,\n      'INVALID_PACKAGE_TARGET',\n      ModuleResolveError.INVALID_PACKAGE_TARGET\n    )\n  }\n\n  static PACKAGE_PATH_NOT_EXPORTED(msg) {\n    return new ModuleResolveError(\n      msg,\n      'PACKAGE_PATH_NOT_EXPORTED',\n      ModuleResolveError.PACKAGE_PATH_NOT_EXPORTED\n    )\n  }\n\n  static PACKAGE_IMPORT_NOT_DEFINED(msg) {\n    return new ModuleResolveError(\n      msg,\n      'PACKAGE_IMPORT_NOT_DEFINED',\n      ModuleResolveError.PACKAGE_IMPORT_NOT_DEFINED\n    )\n  }\n\n  static UNSUPPORTED_ENGINE(msg) {\n    return new ModuleResolveError(\n      msg,\n      'UNSUPPORTED_ENGINE',\n      ModuleResolveError.UNSUPPORTED_ENGINE\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1tb2R1bGUtcmVzb2x2ZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxhQUFhLEtBQUssSUFBSSxJQUFJO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9UYXJ1blNpbmdoL0RvY3VtZW50cy9zdGVsbGVyL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9iYXJlLW1vZHVsZS1yZXNvbHZlL2xpYi9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBNb2R1bGVSZXNvbHZlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSwgZm4gPSBNb2R1bGVSZXNvbHZlRXJyb3IpIHtcbiAgICBzdXBlcihgJHtjb2RlfTogJHttc2d9YClcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGZuKVxuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiAnTW9kdWxlUmVzb2x2ZUVycm9yJ1xuICB9XG5cbiAgc3RhdGljIElOVkFMSURfTU9EVUxFX1NQRUNJRklFUihtc2cpIHtcbiAgICByZXR1cm4gbmV3IE1vZHVsZVJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdJTlZBTElEX01PRFVMRV9TUEVDSUZJRVInLFxuICAgICAgTW9kdWxlUmVzb2x2ZUVycm9yLklOVkFMSURfTU9EVUxFX1NQRUNJRklFUlxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBJTlZBTElEX1BBQ0tBR0VfVEFSR0VUKG1zZykge1xuICAgIHJldHVybiBuZXcgTW9kdWxlUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ0lOVkFMSURfUEFDS0FHRV9UQVJHRVQnLFxuICAgICAgTW9kdWxlUmVzb2x2ZUVycm9yLklOVkFMSURfUEFDS0FHRV9UQVJHRVRcbiAgICApXG4gIH1cblxuICBzdGF0aWMgUEFDS0FHRV9QQVRIX05PVF9FWFBPUlRFRChtc2cpIHtcbiAgICByZXR1cm4gbmV3IE1vZHVsZVJlc29sdmVFcnJvcihcbiAgICAgIG1zZyxcbiAgICAgICdQQUNLQUdFX1BBVEhfTk9UX0VYUE9SVEVEJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5QQUNLQUdFX1BBVEhfTk9UX0VYUE9SVEVEXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIFBBQ0tBR0VfSU1QT1JUX05PVF9ERUZJTkVEKG1zZykge1xuICAgIHJldHVybiBuZXcgTW9kdWxlUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ1BBQ0tBR0VfSU1QT1JUX05PVF9ERUZJTkVEJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5QQUNLQUdFX0lNUE9SVF9OT1RfREVGSU5FRFxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBVTlNVUFBPUlRFRF9FTkdJTkUobXNnKSB7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGVSZXNvbHZlRXJyb3IoXG4gICAgICBtc2csXG4gICAgICAnVU5TVVBQT1JURURfRU5HSU5FJyxcbiAgICAgIE1vZHVsZVJlc29sdmVFcnJvci5VTlNVUFBPUlRFRF9FTkdJTkVcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-module-resolve/lib/errors.js\n");

/***/ })

};
;