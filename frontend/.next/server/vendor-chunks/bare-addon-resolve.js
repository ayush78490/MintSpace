/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bare-addon-resolve";
exports.ids = ["vendor-chunks/bare-addon-resolve"];
exports.modules = {

/***/ "(ssr)/./node_modules/bare-addon-resolve/index.js":
/*!**************************************************!*\
  !*** ./node_modules/bare-addon-resolve/index.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const resolve = __webpack_require__(/*! bare-module-resolve */ \"(ssr)/./node_modules/bare-module-resolve/index.js\")\nconst { Version } = __webpack_require__(/*! bare-semver */ \"(ssr)/./node_modules/bare-semver/index.js\")\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/bare-addon-resolve/lib/errors.js\")\n\nmodule.exports = exports = function resolve(\n  specifier,\n  parentURL,\n  opts,\n  readPackage\n) {\n  if (typeof opts === 'function') {\n    readPackage = opts\n    opts = {}\n  } else if (typeof readPackage !== 'function') {\n    readPackage = defaultReadPackage\n  }\n\n  return {\n    *[Symbol.iterator]() {\n      const generator = exports.addon(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    },\n\n    async *[Symbol.asyncIterator]() {\n      const generator = exports.addon(specifier, parentURL, opts)\n\n      let next = generator.next()\n\n      while (next.done !== true) {\n        const value = next.value\n\n        if (value.package) {\n          next = generator.next(await readPackage(value.package))\n        } else {\n          next = generator.next(yield value.resolution)\n        }\n      }\n\n      return next.value\n    }\n  }\n}\n\nfunction defaultReadPackage() {\n  return null\n}\n\nconst { UNRESOLVED, YIELDED, RESOLVED } = resolve.constants\n\nexports.constants = {\n  UNRESOLVED,\n  YIELDED,\n  RESOLVED\n}\n\nexports.addon = function* (specifier, parentURL, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (exports.startsWithWindowsDriveLetter(specifier)) {\n    specifier = '/' + specifier\n  }\n\n  let status\n\n  if (resolutions) {\n    status = yield* resolve.preresolved(specifier, resolutions, parentURL, opts)\n\n    if (status) return status\n  }\n\n  status = yield* exports.url(specifier, parentURL, opts)\n\n  if (status) return status\n\n  let version = null\n\n  const i = specifier.lastIndexOf('@')\n\n  if (i > 0) {\n    version = specifier.substring(i + 1)\n\n    try {\n      Version.parse(version)\n\n      specifier = specifier.substring(0, i)\n    } catch {\n      version = null\n    }\n  }\n\n  if (\n    specifier === '.' ||\n    specifier === '..' ||\n    specifier[0] === '/' ||\n    specifier[0] === '\\\\' ||\n    specifier.startsWith('./') ||\n    specifier.startsWith('.\\\\') ||\n    specifier.startsWith('../') ||\n    specifier.startsWith('..\\\\')\n  ) {\n    return yield* exports.directory(specifier, version, parentURL, opts)\n  }\n\n  return yield* exports.package(specifier, version, parentURL, opts)\n}\n\nexports.url = function* (url, parentURL, opts = {}) {\n  let resolution\n  try {\n    resolution = new URL(url)\n  } catch {\n    return UNRESOLVED\n  }\n\n  const resolved = yield { resolution }\n\n  return resolved ? RESOLVED : YIELDED\n}\n\nexports[\"package\"] = function* (\n  packageSpecifier,\n  packageVersion,\n  parentURL,\n  opts = {}\n) {\n  if (packageSpecifier === '') {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  let packageName\n\n  if (packageSpecifier[0] !== '@') {\n    packageName = packageSpecifier.split('/', 1).join()\n  } else {\n    if (!packageSpecifier.includes('/')) {\n      throw errors.INVALID_ADDON_SPECIFIER(\n        `Addon specifier '${packageSpecifier}' is not a valid package name`\n      )\n    }\n\n    packageName = packageSpecifier.split('/', 2).join('/')\n  }\n\n  if (\n    packageName[0] === '.' ||\n    packageName.includes('\\\\') ||\n    packageName.includes('%')\n  ) {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${packageSpecifier}' is not a valid package name`\n    )\n  }\n\n  const packageSubpath = '.' + packageSpecifier.substring(packageName.length)\n\n  const status = yield* exports.packageSelf(\n    packageName,\n    packageSubpath,\n    packageVersion,\n    parentURL,\n    opts\n  )\n\n  if (status) return status\n\n  parentURL = new URL(parentURL.href)\n\n  do {\n    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)\n\n    parentURL.pathname = parentURL.pathname.substring(\n      0,\n      parentURL.pathname.lastIndexOf('/')\n    )\n\n    const info = yield { package: new URL('package.json', packageURL) }\n\n    if (info) {\n      return yield* exports.directory(\n        packageSubpath,\n        packageVersion,\n        packageURL,\n        opts\n      )\n    }\n  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')\n\n  return UNRESOLVED\n}\n\nexports.packageSelf = function* (\n  packageName,\n  packageSubpath,\n  packageVersion,\n  parentURL,\n  opts = {}\n) {\n  for (const packageURL of resolve.lookupPackageScope(parentURL, opts)) {\n    const info = yield { package: packageURL }\n\n    if (info) {\n      if (info.name === packageName) {\n        return yield* exports.directory(\n          packageSubpath,\n          packageVersion,\n          packageURL,\n          opts\n        )\n      }\n\n      break\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.lookupPrebuildsScope = function* lookupPrebuildsScope(url, opts = {}) {\n  const { resolutions = null } = opts\n\n  if (resolutions) {\n    for (const { resolution } of resolve.preresolved(\n      '#prebuilds',\n      resolutions,\n      url,\n      opts\n    )) {\n      if (resolution) return yield resolution\n    }\n  }\n\n  const scopeURL = new URL(url.href)\n\n  do {\n    yield new URL('prebuilds/', scopeURL)\n\n    scopeURL.pathname = scopeURL.pathname.substring(\n      0,\n      scopeURL.pathname.lastIndexOf('/')\n    )\n\n    if (\n      scopeURL.pathname.length === 3 &&\n      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))\n    ) {\n      break\n    }\n  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')\n}\n\nexports.file = function* (filename, parentURL, opts = {}) {\n  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {\n    throw errors.INVALID_ADDON_SPECIFIER(\n      `Addon specifier '${filename}' is invalid`\n    )\n  }\n\n  const { extensions = [] } = opts\n\n  let status = UNRESOLVED\n\n  for (const ext of extensions) {\n    if (yield { resolution: new URL(filename + ext, parentURL) }) {\n      return RESOLVED\n    }\n\n    status = YIELDED\n  }\n\n  return status\n}\n\nexports.directory = function* (dirname, version, parentURL, opts = {}) {\n  const {\n    resolutions = null,\n    host = null, // Shorthand for single host resolution\n    hosts = host !== null ? [host] : [],\n    builtins = [],\n    matchedConditions = []\n  } = opts\n\n  let directoryURL\n\n  if (\n    dirname[dirname.length - 1] === '/' ||\n    dirname[dirname.length - 1] === '\\\\'\n  ) {\n    directoryURL = new URL(dirname, parentURL)\n  } else {\n    directoryURL = new URL(dirname + '/', parentURL)\n  }\n\n  // Internal preresolution path, do not depend on this! It will be removed without\n  // warning.\n  if (resolutions) {\n    const status = yield* resolve.preresolved(\n      'bare:addon',\n      resolutions,\n      directoryURL,\n      opts\n    )\n\n    if (status) return status\n  }\n\n  const unversioned = version === null\n\n  let name = null\n\n  const info = yield { package: new URL('package.json', directoryURL) }\n\n  if (info) {\n    if (typeof info.name === 'string' && info.name !== '') {\n      if (info.name.includes('__')) {\n        throw errors.INVALID_PACKAGE_NAME(\n          `Package name '${info.name}' is invalid`\n        )\n      }\n\n      name = info.name.replace(/\\//g, '__').replace(/^@/, '')\n    } else {\n      return UNRESOLVED\n    }\n\n    if (typeof info.version === 'string' && info.version !== '') {\n      if (version !== null && info.version !== version) return UNRESOLVED\n\n      version = info.version\n    }\n  } else {\n    return UNRESOLVED\n  }\n\n  let status\n\n  status = yield* resolve.builtinTarget(name, version, builtins, opts)\n\n  if (status) return status\n\n  for (const prebuildsURL of exports.lookupPrebuildsScope(directoryURL, opts)) {\n    status = UNRESOLVED\n\n    for (const host of hosts) {\n      const conditions = host.split('-')\n\n      matchedConditions.push(...conditions)\n\n      if (version !== null) {\n        status |= yield* exports.file(\n          host + '/' + name + '@' + version,\n          prebuildsURL,\n          opts\n        )\n      }\n\n      if (unversioned) {\n        status |= yield* exports.file(host + '/' + name, prebuildsURL, opts)\n      }\n\n      for (const _ of conditions) matchedConditions.pop()\n    }\n\n    if (status === RESOLVED) return status\n  }\n\n  return yield* exports.linked(name, version, opts)\n}\n\nexports.linked = function* (name, version = null, opts = {}) {\n  const {\n    linked = true,\n    host = null, // Shorthand for single host resolution\n    hosts = host !== null ? [host] : [],\n    matchedConditions = []\n  } = opts\n\n  if (linked === false || hosts.length === 0) return UNRESOLVED\n\n  let status = UNRESOLVED\n\n  for (const host of hosts) {\n    const [platform = null] = host.split('-', 1)\n\n    if (platform === null) continue\n\n    matchedConditions.push(platform)\n\n    status |= yield* platformArtefact(name, version, platform, opts)\n\n    matchedConditions.pop()\n  }\n\n  return status\n}\n\nfunction* platformArtefact(name, version = null, platform, opts = {}) {\n  const { linkedProtocol = 'linked:' } = opts\n\n  if (platform === 'darwin' || platform === 'ios') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(\n            `${linkedProtocol}${name}.${version}.framework/${name}.${version}`\n          )\n        }\n      ) {\n        return RESOLVED\n      }\n\n      if (platform === 'darwin') {\n        if (\n          yield {\n            resolution: new URL(`${linkedProtocol}lib${name}.${version}.dylib`)\n          }\n        ) {\n          return RESOLVED\n        }\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}${name}.framework/${name}`)\n      }\n    ) {\n      return RESOLVED\n    }\n\n    if (platform === 'darwin') {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}lib${name}.dylib`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    return YIELDED\n  }\n\n  if (platform === 'linux' || platform === 'android') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}lib${name}.${version}.so`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}lib${name}.so`)\n      }\n    ) {\n      return RESOLVED\n    }\n\n    return YIELDED\n  }\n\n  if (platform === 'win32') {\n    if (version !== null) {\n      if (\n        yield {\n          resolution: new URL(`${linkedProtocol}${name}-${version}.dll`)\n        }\n      ) {\n        return RESOLVED\n      }\n    }\n\n    if (\n      yield {\n        resolution: new URL(`${linkedProtocol}${name}.dll`)\n      }\n    ) {\n      return RESOLVED\n    }\n  }\n\n  return UNRESOLVED\n}\n\nexports.isWindowsDriveLetter = resolve.isWindowsDriveLetter\n\nexports.startsWithWindowsDriveLetter = resolve.startsWithWindowsDriveLetter\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFxQjtBQUM3QyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywyRUFBYzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQ0FBZ0M7O0FBRXhDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDZDQUE2QztBQUMxRCxVQUFVLHFCQUFxQjs7QUFFL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsdUNBQXVDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZSxFQUFFLEtBQUssR0FBRyxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixlQUFlLEVBQUUsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixvQ0FBb0MiLCJzb3VyY2VzIjpbIi9ob21lL1RhcnVuU2luZ2gvRG9jdW1lbnRzL3N0ZWxsZXIvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2JhcmUtYWRkb24tcmVzb2x2ZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZXNvbHZlID0gcmVxdWlyZSgnYmFyZS1tb2R1bGUtcmVzb2x2ZScpXG5jb25zdCB7IFZlcnNpb24gfSA9IHJlcXVpcmUoJ2JhcmUtc2VtdmVyJylcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vbGliL2Vycm9ycycpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uIHJlc29sdmUoXG4gIHNwZWNpZmllcixcbiAgcGFyZW50VVJMLFxuICBvcHRzLFxuICByZWFkUGFja2FnZVxuKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlYWRQYWNrYWdlID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkUGFja2FnZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlYWRQYWNrYWdlID0gZGVmYXVsdFJlYWRQYWNrYWdlXG4gIH1cblxuICByZXR1cm4ge1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGV4cG9ydHMuYWRkb24oc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMpXG5cbiAgICAgIGxldCBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoKVxuXG4gICAgICB3aGlsZSAobmV4dC5kb25lICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV4dC52YWx1ZVxuXG4gICAgICAgIGlmICh2YWx1ZS5wYWNrYWdlKSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHJlYWRQYWNrYWdlKHZhbHVlLnBhY2thZ2UpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBnZW5lcmF0b3IubmV4dCh5aWVsZCB2YWx1ZS5yZXNvbHV0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfSxcblxuICAgIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZXhwb3J0cy5hZGRvbihzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICAgICAgbGV0IG5leHQgPSBnZW5lcmF0b3IubmV4dCgpXG5cbiAgICAgIHdoaWxlIChuZXh0LmRvbmUgIT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXh0LnZhbHVlXG5cbiAgICAgICAgaWYgKHZhbHVlLnBhY2thZ2UpIHtcbiAgICAgICAgICBuZXh0ID0gZ2VuZXJhdG9yLm5leHQoYXdhaXQgcmVhZFBhY2thZ2UodmFsdWUucGFja2FnZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGdlbmVyYXRvci5uZXh0KHlpZWxkIHZhbHVlLnJlc29sdXRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHQudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlYWRQYWNrYWdlKCkge1xuICByZXR1cm4gbnVsbFxufVxuXG5jb25zdCB7IFVOUkVTT0xWRUQsIFlJRUxERUQsIFJFU09MVkVEIH0gPSByZXNvbHZlLmNvbnN0YW50c1xuXG5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgVU5SRVNPTFZFRCxcbiAgWUlFTERFRCxcbiAgUkVTT0xWRURcbn1cblxuZXhwb3J0cy5hZGRvbiA9IGZ1bmN0aW9uKiAoc3BlY2lmaWVyLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHJlc29sdXRpb25zID0gbnVsbCB9ID0gb3B0c1xuXG4gIGlmIChleHBvcnRzLnN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoc3BlY2lmaWVyKSkge1xuICAgIHNwZWNpZmllciA9ICcvJyArIHNwZWNpZmllclxuICB9XG5cbiAgbGV0IHN0YXR1c1xuXG4gIGlmIChyZXNvbHV0aW9ucykge1xuICAgIHN0YXR1cyA9IHlpZWxkKiByZXNvbHZlLnByZXJlc29sdmVkKHNwZWNpZmllciwgcmVzb2x1dGlvbnMsIHBhcmVudFVSTCwgb3B0cylcblxuICAgIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcbiAgfVxuXG4gIHN0YXR1cyA9IHlpZWxkKiBleHBvcnRzLnVybChzcGVjaWZpZXIsIHBhcmVudFVSTCwgb3B0cylcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgbGV0IHZlcnNpb24gPSBudWxsXG5cbiAgY29uc3QgaSA9IHNwZWNpZmllci5sYXN0SW5kZXhPZignQCcpXG5cbiAgaWYgKGkgPiAwKSB7XG4gICAgdmVyc2lvbiA9IHNwZWNpZmllci5zdWJzdHJpbmcoaSArIDEpXG5cbiAgICB0cnkge1xuICAgICAgVmVyc2lvbi5wYXJzZSh2ZXJzaW9uKVxuXG4gICAgICBzcGVjaWZpZXIgPSBzcGVjaWZpZXIuc3Vic3RyaW5nKDAsIGkpXG4gICAgfSBjYXRjaCB7XG4gICAgICB2ZXJzaW9uID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGlmIChcbiAgICBzcGVjaWZpZXIgPT09ICcuJyB8fFxuICAgIHNwZWNpZmllciA9PT0gJy4uJyB8fFxuICAgIHNwZWNpZmllclswXSA9PT0gJy8nIHx8XG4gICAgc3BlY2lmaWVyWzBdID09PSAnXFxcXCcgfHxcbiAgICBzcGVjaWZpZXIuc3RhcnRzV2l0aCgnLi8nKSB8fFxuICAgIHNwZWNpZmllci5zdGFydHNXaXRoKCcuXFxcXCcpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uLycpIHx8XG4gICAgc3BlY2lmaWVyLnN0YXJ0c1dpdGgoJy4uXFxcXCcpXG4gICkge1xuICAgIHJldHVybiB5aWVsZCogZXhwb3J0cy5kaXJlY3Rvcnkoc3BlY2lmaWVyLCB2ZXJzaW9uLCBwYXJlbnRVUkwsIG9wdHMpXG4gIH1cblxuICByZXR1cm4geWllbGQqIGV4cG9ydHMucGFja2FnZShzcGVjaWZpZXIsIHZlcnNpb24sIHBhcmVudFVSTCwgb3B0cylcbn1cblxuZXhwb3J0cy51cmwgPSBmdW5jdGlvbiogKHVybCwgcGFyZW50VVJMLCBvcHRzID0ge30pIHtcbiAgbGV0IHJlc29sdXRpb25cbiAgdHJ5IHtcbiAgICByZXNvbHV0aW9uID0gbmV3IFVSTCh1cmwpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBVTlJFU09MVkVEXG4gIH1cblxuICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHsgcmVzb2x1dGlvbiB9XG5cbiAgcmV0dXJuIHJlc29sdmVkID8gUkVTT0xWRUQgOiBZSUVMREVEXG59XG5cbmV4cG9ydHMucGFja2FnZSA9IGZ1bmN0aW9uKiAoXG4gIHBhY2thZ2VTcGVjaWZpZXIsXG4gIHBhY2thZ2VWZXJzaW9uLFxuICBwYXJlbnRVUkwsXG4gIG9wdHMgPSB7fVxuKSB7XG4gIGlmIChwYWNrYWdlU3BlY2lmaWVyID09PSAnJykge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX0FERE9OX1NQRUNJRklFUihcbiAgICAgIGBBZGRvbiBzcGVjaWZpZXIgJyR7cGFja2FnZVNwZWNpZmllcn0nIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZWBcbiAgICApXG4gIH1cblxuICBsZXQgcGFja2FnZU5hbWVcblxuICBpZiAocGFja2FnZVNwZWNpZmllclswXSAhPT0gJ0AnKSB7XG4gICAgcGFja2FnZU5hbWUgPSBwYWNrYWdlU3BlY2lmaWVyLnNwbGl0KCcvJywgMSkuam9pbigpXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFwYWNrYWdlU3BlY2lmaWVyLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgIHRocm93IGVycm9ycy5JTlZBTElEX0FERE9OX1NQRUNJRklFUihcbiAgICAgICAgYEFkZG9uIHNwZWNpZmllciAnJHtwYWNrYWdlU3BlY2lmaWVyfScgaXMgbm90IGEgdmFsaWQgcGFja2FnZSBuYW1lYFxuICAgICAgKVxuICAgIH1cblxuICAgIHBhY2thZ2VOYW1lID0gcGFja2FnZVNwZWNpZmllci5zcGxpdCgnLycsIDIpLmpvaW4oJy8nKVxuICB9XG5cbiAgaWYgKFxuICAgIHBhY2thZ2VOYW1lWzBdID09PSAnLicgfHxcbiAgICBwYWNrYWdlTmFtZS5pbmNsdWRlcygnXFxcXCcpIHx8XG4gICAgcGFja2FnZU5hbWUuaW5jbHVkZXMoJyUnKVxuICApIHtcbiAgICB0aHJvdyBlcnJvcnMuSU5WQUxJRF9BRERPTl9TUEVDSUZJRVIoXG4gICAgICBgQWRkb24gc3BlY2lmaWVyICcke3BhY2thZ2VTcGVjaWZpZXJ9JyBpcyBub3QgYSB2YWxpZCBwYWNrYWdlIG5hbWVgXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcGFja2FnZVN1YnBhdGggPSAnLicgKyBwYWNrYWdlU3BlY2lmaWVyLnN1YnN0cmluZyhwYWNrYWdlTmFtZS5sZW5ndGgpXG5cbiAgY29uc3Qgc3RhdHVzID0geWllbGQqIGV4cG9ydHMucGFja2FnZVNlbGYoXG4gICAgcGFja2FnZU5hbWUsXG4gICAgcGFja2FnZVN1YnBhdGgsXG4gICAgcGFja2FnZVZlcnNpb24sXG4gICAgcGFyZW50VVJMLFxuICAgIG9wdHNcbiAgKVxuXG4gIGlmIChzdGF0dXMpIHJldHVybiBzdGF0dXNcblxuICBwYXJlbnRVUkwgPSBuZXcgVVJMKHBhcmVudFVSTC5ocmVmKVxuXG4gIGRvIHtcbiAgICBjb25zdCBwYWNrYWdlVVJMID0gbmV3IFVSTCgnbm9kZV9tb2R1bGVzLycgKyBwYWNrYWdlTmFtZSArICcvJywgcGFyZW50VVJMKVxuXG4gICAgcGFyZW50VVJMLnBhdGhuYW1lID0gcGFyZW50VVJMLnBhdGhuYW1lLnN1YnN0cmluZyhcbiAgICAgIDAsXG4gICAgICBwYXJlbnRVUkwucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKVxuICAgIClcblxuICAgIGNvbnN0IGluZm8gPSB5aWVsZCB7IHBhY2thZ2U6IG5ldyBVUkwoJ3BhY2thZ2UuanNvbicsIHBhY2thZ2VVUkwpIH1cblxuICAgIGlmIChpbmZvKSB7XG4gICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KFxuICAgICAgICBwYWNrYWdlU3VicGF0aCxcbiAgICAgICAgcGFja2FnZVZlcnNpb24sXG4gICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgIG9wdHNcbiAgICAgIClcbiAgICB9XG4gIH0gd2hpbGUgKHBhcmVudFVSTC5wYXRobmFtZSAhPT0gJycgJiYgcGFyZW50VVJMLnBhdGhuYW1lICE9PSAnLycpXG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5wYWNrYWdlU2VsZiA9IGZ1bmN0aW9uKiAoXG4gIHBhY2thZ2VOYW1lLFxuICBwYWNrYWdlU3VicGF0aCxcbiAgcGFja2FnZVZlcnNpb24sXG4gIHBhcmVudFVSTCxcbiAgb3B0cyA9IHt9XG4pIHtcbiAgZm9yIChjb25zdCBwYWNrYWdlVVJMIG9mIHJlc29sdmUubG9va3VwUGFja2FnZVNjb3BlKHBhcmVudFVSTCwgb3B0cykpIHtcbiAgICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBwYWNrYWdlVVJMIH1cblxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpZiAoaW5mby5uYW1lID09PSBwYWNrYWdlTmFtZSkge1xuICAgICAgICByZXR1cm4geWllbGQqIGV4cG9ydHMuZGlyZWN0b3J5KFxuICAgICAgICAgIHBhY2thZ2VTdWJwYXRoLFxuICAgICAgICAgIHBhY2thZ2VWZXJzaW9uLFxuICAgICAgICAgIHBhY2thZ2VVUkwsXG4gICAgICAgICAgb3B0c1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOUkVTT0xWRURcbn1cblxuZXhwb3J0cy5sb29rdXBQcmVidWlsZHNTY29wZSA9IGZ1bmN0aW9uKiBsb29rdXBQcmVidWlsZHNTY29wZSh1cmwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHJlc29sdXRpb25zID0gbnVsbCB9ID0gb3B0c1xuXG4gIGlmIChyZXNvbHV0aW9ucykge1xuICAgIGZvciAoY29uc3QgeyByZXNvbHV0aW9uIH0gb2YgcmVzb2x2ZS5wcmVyZXNvbHZlZChcbiAgICAgICcjcHJlYnVpbGRzJyxcbiAgICAgIHJlc29sdXRpb25zLFxuICAgICAgdXJsLFxuICAgICAgb3B0c1xuICAgICkpIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uKSByZXR1cm4geWllbGQgcmVzb2x1dGlvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNjb3BlVVJMID0gbmV3IFVSTCh1cmwuaHJlZilcblxuICBkbyB7XG4gICAgeWllbGQgbmV3IFVSTCgncHJlYnVpbGRzLycsIHNjb3BlVVJMKVxuXG4gICAgc2NvcGVVUkwucGF0aG5hbWUgPSBzY29wZVVSTC5wYXRobmFtZS5zdWJzdHJpbmcoXG4gICAgICAwLFxuICAgICAgc2NvcGVVUkwucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKVxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHNjb3BlVVJMLnBhdGhuYW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgZXhwb3J0cy5pc1dpbmRvd3NEcml2ZUxldHRlcihzY29wZVVSTC5wYXRobmFtZS5zdWJzdHJpbmcoMSkpXG4gICAgKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfSB3aGlsZSAoc2NvcGVVUkwucGF0aG5hbWUgIT09ICcnICYmIHNjb3BlVVJMLnBhdGhuYW1lICE9PSAnLycpXG59XG5cbmV4cG9ydHMuZmlsZSA9IGZ1bmN0aW9uKiAoZmlsZW5hbWUsIHBhcmVudFVSTCwgb3B0cyA9IHt9KSB7XG4gIGlmIChwYXJlbnRVUkwucHJvdG9jb2wgPT09ICdmaWxlOicgJiYgLyUyZnwlNWMvaS50ZXN0KGZpbGVuYW1lKSkge1xuICAgIHRocm93IGVycm9ycy5JTlZBTElEX0FERE9OX1NQRUNJRklFUihcbiAgICAgIGBBZGRvbiBzcGVjaWZpZXIgJyR7ZmlsZW5hbWV9JyBpcyBpbnZhbGlkYFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHsgZXh0ZW5zaW9ucyA9IFtdIH0gPSBvcHRzXG5cbiAgbGV0IHN0YXR1cyA9IFVOUkVTT0xWRURcblxuICBmb3IgKGNvbnN0IGV4dCBvZiBleHRlbnNpb25zKSB7XG4gICAgaWYgKHlpZWxkIHsgcmVzb2x1dGlvbjogbmV3IFVSTChmaWxlbmFtZSArIGV4dCwgcGFyZW50VVJMKSB9KSB7XG4gICAgICByZXR1cm4gUkVTT0xWRURcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBZSUVMREVEXG4gIH1cblxuICByZXR1cm4gc3RhdHVzXG59XG5cbmV4cG9ydHMuZGlyZWN0b3J5ID0gZnVuY3Rpb24qIChkaXJuYW1lLCB2ZXJzaW9uLCBwYXJlbnRVUkwsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcmVzb2x1dGlvbnMgPSBudWxsLFxuICAgIGhvc3QgPSBudWxsLCAvLyBTaG9ydGhhbmQgZm9yIHNpbmdsZSBob3N0IHJlc29sdXRpb25cbiAgICBob3N0cyA9IGhvc3QgIT09IG51bGwgPyBbaG9zdF0gOiBbXSxcbiAgICBidWlsdGlucyA9IFtdLFxuICAgIG1hdGNoZWRDb25kaXRpb25zID0gW11cbiAgfSA9IG9wdHNcblxuICBsZXQgZGlyZWN0b3J5VVJMXG5cbiAgaWYgKFxuICAgIGRpcm5hbWVbZGlybmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nIHx8XG4gICAgZGlybmFtZVtkaXJuYW1lLmxlbmd0aCAtIDFdID09PSAnXFxcXCdcbiAgKSB7XG4gICAgZGlyZWN0b3J5VVJMID0gbmV3IFVSTChkaXJuYW1lLCBwYXJlbnRVUkwpXG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0b3J5VVJMID0gbmV3IFVSTChkaXJuYW1lICsgJy8nLCBwYXJlbnRVUkwpXG4gIH1cblxuICAvLyBJbnRlcm5hbCBwcmVyZXNvbHV0aW9uIHBhdGgsIGRvIG5vdCBkZXBlbmQgb24gdGhpcyEgSXQgd2lsbCBiZSByZW1vdmVkIHdpdGhvdXRcbiAgLy8gd2FybmluZy5cbiAgaWYgKHJlc29sdXRpb25zKSB7XG4gICAgY29uc3Qgc3RhdHVzID0geWllbGQqIHJlc29sdmUucHJlcmVzb2x2ZWQoXG4gICAgICAnYmFyZTphZGRvbicsXG4gICAgICByZXNvbHV0aW9ucyxcbiAgICAgIGRpcmVjdG9yeVVSTCxcbiAgICAgIG9wdHNcbiAgICApXG5cbiAgICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG4gIH1cblxuICBjb25zdCB1bnZlcnNpb25lZCA9IHZlcnNpb24gPT09IG51bGxcblxuICBsZXQgbmFtZSA9IG51bGxcblxuICBjb25zdCBpbmZvID0geWllbGQgeyBwYWNrYWdlOiBuZXcgVVJMKCdwYWNrYWdlLmpzb24nLCBkaXJlY3RvcnlVUkwpIH1cblxuICBpZiAoaW5mbykge1xuICAgIGlmICh0eXBlb2YgaW5mby5uYW1lID09PSAnc3RyaW5nJyAmJiBpbmZvLm5hbWUgIT09ICcnKSB7XG4gICAgICBpZiAoaW5mby5uYW1lLmluY2x1ZGVzKCdfXycpKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JTlZBTElEX1BBQ0tBR0VfTkFNRShcbiAgICAgICAgICBgUGFja2FnZSBuYW1lICcke2luZm8ubmFtZX0nIGlzIGludmFsaWRgXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IGluZm8ubmFtZS5yZXBsYWNlKC9cXC8vZywgJ19fJykucmVwbGFjZSgvXkAvLCAnJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFVOUkVTT0xWRURcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluZm8udmVyc2lvbiA9PT0gJ3N0cmluZycgJiYgaW5mby52ZXJzaW9uICE9PSAnJykge1xuICAgICAgaWYgKHZlcnNpb24gIT09IG51bGwgJiYgaW5mby52ZXJzaW9uICE9PSB2ZXJzaW9uKSByZXR1cm4gVU5SRVNPTFZFRFxuXG4gICAgICB2ZXJzaW9uID0gaW5mby52ZXJzaW9uXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBVTlJFU09MVkVEXG4gIH1cblxuICBsZXQgc3RhdHVzXG5cbiAgc3RhdHVzID0geWllbGQqIHJlc29sdmUuYnVpbHRpblRhcmdldChuYW1lLCB2ZXJzaW9uLCBidWlsdGlucywgb3B0cylcblxuICBpZiAoc3RhdHVzKSByZXR1cm4gc3RhdHVzXG5cbiAgZm9yIChjb25zdCBwcmVidWlsZHNVUkwgb2YgZXhwb3J0cy5sb29rdXBQcmVidWlsZHNTY29wZShkaXJlY3RvcnlVUkwsIG9wdHMpKSB7XG4gICAgc3RhdHVzID0gVU5SRVNPTFZFRFxuXG4gICAgZm9yIChjb25zdCBob3N0IG9mIGhvc3RzKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25zID0gaG9zdC5zcGxpdCgnLScpXG5cbiAgICAgIG1hdGNoZWRDb25kaXRpb25zLnB1c2goLi4uY29uZGl0aW9ucylcblxuICAgICAgaWYgKHZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgc3RhdHVzIHw9IHlpZWxkKiBleHBvcnRzLmZpbGUoXG4gICAgICAgICAgaG9zdCArICcvJyArIG5hbWUgKyAnQCcgKyB2ZXJzaW9uLFxuICAgICAgICAgIHByZWJ1aWxkc1VSTCxcbiAgICAgICAgICBvcHRzXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHVudmVyc2lvbmVkKSB7XG4gICAgICAgIHN0YXR1cyB8PSB5aWVsZCogZXhwb3J0cy5maWxlKGhvc3QgKyAnLycgKyBuYW1lLCBwcmVidWlsZHNVUkwsIG9wdHMpXG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgXyBvZiBjb25kaXRpb25zKSBtYXRjaGVkQ29uZGl0aW9ucy5wb3AoKVxuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IFJFU09MVkVEKSByZXR1cm4gc3RhdHVzXG4gIH1cblxuICByZXR1cm4geWllbGQqIGV4cG9ydHMubGlua2VkKG5hbWUsIHZlcnNpb24sIG9wdHMpXG59XG5cbmV4cG9ydHMubGlua2VkID0gZnVuY3Rpb24qIChuYW1lLCB2ZXJzaW9uID0gbnVsbCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBsaW5rZWQgPSB0cnVlLFxuICAgIGhvc3QgPSBudWxsLCAvLyBTaG9ydGhhbmQgZm9yIHNpbmdsZSBob3N0IHJlc29sdXRpb25cbiAgICBob3N0cyA9IGhvc3QgIT09IG51bGwgPyBbaG9zdF0gOiBbXSxcbiAgICBtYXRjaGVkQ29uZGl0aW9ucyA9IFtdXG4gIH0gPSBvcHRzXG5cbiAgaWYgKGxpbmtlZCA9PT0gZmFsc2UgfHwgaG9zdHMubGVuZ3RoID09PSAwKSByZXR1cm4gVU5SRVNPTFZFRFxuXG4gIGxldCBzdGF0dXMgPSBVTlJFU09MVkVEXG5cbiAgZm9yIChjb25zdCBob3N0IG9mIGhvc3RzKSB7XG4gICAgY29uc3QgW3BsYXRmb3JtID0gbnVsbF0gPSBob3N0LnNwbGl0KCctJywgMSlcblxuICAgIGlmIChwbGF0Zm9ybSA9PT0gbnVsbCkgY29udGludWVcblxuICAgIG1hdGNoZWRDb25kaXRpb25zLnB1c2gocGxhdGZvcm0pXG5cbiAgICBzdGF0dXMgfD0geWllbGQqIHBsYXRmb3JtQXJ0ZWZhY3QobmFtZSwgdmVyc2lvbiwgcGxhdGZvcm0sIG9wdHMpXG5cbiAgICBtYXRjaGVkQ29uZGl0aW9ucy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHN0YXR1c1xufVxuXG5mdW5jdGlvbiogcGxhdGZvcm1BcnRlZmFjdChuYW1lLCB2ZXJzaW9uID0gbnVsbCwgcGxhdGZvcm0sIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGxpbmtlZFByb3RvY29sID0gJ2xpbmtlZDonIH0gPSBvcHRzXG5cbiAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJyB8fCBwbGF0Zm9ybSA9PT0gJ2lvcycpIHtcbiAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKFxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChcbiAgICAgICAgICAgIGAke2xpbmtlZFByb3RvY29sfSR7bmFtZX0uJHt2ZXJzaW9ufS5mcmFtZXdvcmsvJHtuYW1lfS4ke3ZlcnNpb259YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgICAgfVxuXG4gICAgICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfWxpYiR7bmFtZX0uJHt2ZXJzaW9ufS5keWxpYmApXG4gICAgICAgICAgfVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gUkVTT0xWRURcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH0ke25hbWV9LmZyYW1ld29yay8ke25hbWV9YClcbiAgICAgIH1cbiAgICApIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cblxuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgIGlmIChcbiAgICAgICAgeWllbGQge1xuICAgICAgICAgIHJlc29sdXRpb246IG5ldyBVUkwoYCR7bGlua2VkUHJvdG9jb2x9bGliJHtuYW1lfS5keWxpYmApXG4gICAgICAgIH1cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gUkVTT0xWRURcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWUlFTERFRFxuICB9XG5cbiAgaWYgKHBsYXRmb3JtID09PSAnbGludXgnIHx8IHBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICBpZiAodmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKFxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3IFVSTChgJHtsaW5rZWRQcm90b2NvbH1saWIke25hbWV9LiR7dmVyc2lvbn0uc29gKVxuICAgICAgICB9XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgeWllbGQge1xuICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfWxpYiR7bmFtZX0uc29gKVxuICAgICAgfVxuICAgICkge1xuICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgfVxuXG4gICAgcmV0dXJuIFlJRUxERURcbiAgfVxuXG4gIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGlmICh2ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfSR7bmFtZX0tJHt2ZXJzaW9ufS5kbGxgKVxuICAgICAgICB9XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIFJFU09MVkVEXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgeWllbGQge1xuICAgICAgICByZXNvbHV0aW9uOiBuZXcgVVJMKGAke2xpbmtlZFByb3RvY29sfSR7bmFtZX0uZGxsYClcbiAgICAgIH1cbiAgICApIHtcbiAgICAgIHJldHVybiBSRVNPTFZFRFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBVTlJFU09MVkVEXG59XG5cbmV4cG9ydHMuaXNXaW5kb3dzRHJpdmVMZXR0ZXIgPSByZXNvbHZlLmlzV2luZG93c0RyaXZlTGV0dGVyXG5cbmV4cG9ydHMuc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IHJlc29sdmUuc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-addon-resolve/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bare-addon-resolve/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/bare-addon-resolve/lib/errors.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("module.exports = class AddonResolveError extends Error {\n  constructor(msg, code, fn = AddonResolveError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'AddonResolveError'\n  }\n\n  static INVALID_ADDON_SPECIFIER(msg) {\n    return new AddonResolveError(\n      msg,\n      'INVALID_ADDON_SPECIFIER',\n      AddonResolveError.INVALID_ADDON_SPECIFIER\n    )\n  }\n\n  static INVALID_PACKAGE_NAME(msg) {\n    return new AddonResolveError(\n      msg,\n      'INVALID_PACKAGE_NAME',\n      AddonResolveError.INVALID_PACKAGE_NAME\n    )\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyZS1hZGRvbi1yZXNvbHZlL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsS0FBSyxJQUFJLElBQUk7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL1RhcnVuU2luZ2gvRG9jdW1lbnRzL3N0ZWxsZXIvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2JhcmUtYWRkb24tcmVzb2x2ZS9saWIvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQWRkb25SZXNvbHZlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSwgZm4gPSBBZGRvblJlc29sdmVFcnJvcikge1xuICAgIHN1cGVyKGAke2NvZGV9OiAke21zZ31gKVxuICAgIHRoaXMuY29kZSA9IGNvZGVcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZm4pXG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuICdBZGRvblJlc29sdmVFcnJvcidcbiAgfVxuXG4gIHN0YXRpYyBJTlZBTElEX0FERE9OX1NQRUNJRklFUihtc2cpIHtcbiAgICByZXR1cm4gbmV3IEFkZG9uUmVzb2x2ZUVycm9yKFxuICAgICAgbXNnLFxuICAgICAgJ0lOVkFMSURfQURET05fU1BFQ0lGSUVSJyxcbiAgICAgIEFkZG9uUmVzb2x2ZUVycm9yLklOVkFMSURfQURET05fU1BFQ0lGSUVSXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIElOVkFMSURfUEFDS0FHRV9OQU1FKG1zZykge1xuICAgIHJldHVybiBuZXcgQWRkb25SZXNvbHZlRXJyb3IoXG4gICAgICBtc2csXG4gICAgICAnSU5WQUxJRF9QQUNLQUdFX05BTUUnLFxuICAgICAgQWRkb25SZXNvbHZlRXJyb3IuSU5WQUxJRF9QQUNLQUdFX05BTUVcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bare-addon-resolve/lib/errors.js\n");

/***/ })

};
;